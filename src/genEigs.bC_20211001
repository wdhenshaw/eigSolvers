// ==================================================================================================
// Solve a generalized eigenvalue problem with SLEPc
//            A x = k B x
// 
// Started from SLEPc examples:
//      src/eps/examples/tutorials/ex2.c  : Laplace
//      src/eps/examples/tutorials/ex7.c  : generalized eig problem, read matrices from files
// ==================================================================================================






static char help[] = "Solves a generalized eigensystem Ax=kBx with matrices loaded from a file.\n"
  "This example works for both real and complex numbers.\n\n"
  "The command line options are:\n"
  "  -f1 <filename>, where <filename> = matrix (A) file in PETSc binary form.\n"
  "  -f2 <filename>, where <filename> = matrix (B) file in PETSc binary form.\n"
  "  -evecs <filename>, output file to save computed eigenvectors.\n"
  "  -ninitial <nini>, number of user-provided initial guesses.\n"
  "  -finitial <filename>, where <filename> contains <nini> vectors (binary).\n"
  "  -nconstr <ncon>, number of user-provided constraints.\n"
  "  -fconstr <filename>, where <filename> contains <ncon> vectors (binary).\n\n";

#include <slepceps.h>

#include "Overture.h"
#include "display.h"
#include "PlotStuff.h"  
#include "SquareMapping.h" 

#include "CompositeGridOperators.h"
#include "SparseRep.h" 

#define FOR_3D(i1,i2,i3,I1,I2,I3) \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(int i3=I3Base; i3<=I3Bound; i3++) \
for(int i2=I2Base; i2<=I2Bound; i2++) \
for(int i1=I1Base; i1<=I1Bound; i1++)  

#define ForBoundary(side,axis)   for( int axis=0; axis<numberOfDimensions; axis++ ) \
                                 for( int side=0; side<=1; side++ )  

// ============================================================================
// Compute the global matrix index ig from the grid-function index (i1,i2,i3)
// ===========================================================================
#beginMacro getGlobalIndex(i1,i2,i3,ig)
  ig = (i1)-n1a + nd1a*( (i2)-n2a );
#endMacro

// =================================================================================
// Compute the local grid-function index (i1,i2,i3) from the global matrix index ig
// ================================================================================
#beginMacro getLocalIndex( ig,i1,i2,i3 )
   i3 = 0;
   i2 = n2a + ig/nd1a;
   i1 = ig + n1a - nd1a*( (i2)-n2a );
#endMacro


// ==================================================================================
// Fill in the PETSc matrices A and B 
//          minus-Laplacian 
// ==================================================================================
int
fillMatrixLaplacian( int orderOfAccuracy, MappedGrid & mg, Mat & A, Mat & B, int numGhost, bool useNew, Real tol )
{
  PetscBool flag;
  int Istart,Iend,ierr;

  const int numberOfDimensions = mg.numberOfDimensions();

  const bool isRectangular = mg.isRectangular();
  real dx[3]={1.,1.,1.};
  if( isRectangular )
    mg.getDeltaX(dx);

  assert( isRectangular );

  const IntegerArray & gid = mg.gridIndexRange();

  // No boundary points: 
  int n = gid(1,0)-gid(0,0)+1 - 2;
  int m = gid(1,1)-gid(0,1)+1 - 2;

  const int nd1a = gid(1,0)-gid(0,0)+1 + 2*numGhost;
  const int nd2a = gid(1,1)-gid(0,1)+1 + 2*numGhost;

  const int n1a = gid(0,0)-numGhost;
  const int n2a = gid(0,1)-numGhost;

  const int n1b = gid(1,0)+numGhost;
  const int n2b = gid(1,1)+numGhost;


  // int orderOfAccuracy=2;
  const int extrapOrder = orderOfAccuracy+1;

  const Real extrapCoeff3[] = {1.,-3.,3.,-1.};
  const Real extrapCoeff4[] = {1.,-4.,6.,-4.,1.};
  const Real extrapCoeff5[] = {1.,-5.,10.,-10.,5.,-1.};
  const Real extrapCoeff6[] = {1.,-6.,15.,-20.,15.,-6.,1.};
  const Real extrapCoeff7[] = {1.,-7.,21.,-35.,35.,-21.,7.,-1.};
  const Real extrapCoeff8[] = {1.,-8.,28.,-56.,70.,-56.,28.,-8.,1.};
  const Real extrapCoeff9[] = {1.,-9.,36.,-84.,126.,-126.,84.,-36.,9.,-1.};
  const Real *extrapCoeff;
  if( extrapOrder==3 )
    extrapCoeff = extrapCoeff3;
  else if( extrapOrder==4 )
    extrapCoeff = extrapCoeff4;
  else if( extrapOrder==5 )
    extrapCoeff = extrapCoeff5;
  else if( extrapOrder==6 )
    extrapCoeff = extrapCoeff6;
  else if( extrapOrder==7 )
    extrapCoeff = extrapCoeff7;    
  else if( extrapOrder==8 )
    extrapCoeff = extrapCoeff8;     
  else if( extrapOrder==9 )
    extrapCoeff = extrapCoeff9;               
  else
   {
    printF("fillMatrixLaplacian:: unexpected extrapOrder=%d\n",extrapOrder);
    OV_ABORT("ERROR");
   }

  int i1,i2,i3;

  // int N = n*m;
  int N = nd1a*nd2a;

  // ----- MATRIX A -----

  Real dx2i = 1./(dx[0]*dx[0]);
  Real dy2i = 1./(dx[1]*dx[1]);
  Real diag = 2.*dx2i + 2.*dy2i; 

  int hw = orderOfAccuracy/2; // stencil half with
  Range S(-hw,hw); // stencil
  RealArray coeff(S,S);
  coeff=0.;
  if( orderOfAccuracy==2 )
  {
    // ----  -Delta : order=2 ----
    coeff(0,0)  =  2./SQR(dx[0]) + 2./SQR(dx[1]);

    coeff(-1,0) = -1./SQR(dx[0]);
    coeff(+1,0) = -1./SQR(dx[0]);

    coeff(0,-1) = -1./SQR(dx[1]);
    coeff(0,+1) = -1./SQR(dx[1]);    
  }
  else if( orderOfAccuracy==4 )
  {
    // ----  -Delta : order=4 ----
    coeff(0,0)  =  30./(12.*SQR(dx[0])) + 30./(12.*SQR(dx[1]));

    coeff(-2,0) =   1./(12.*SQR(dx[0]));
    coeff(-1,0) = -16./(12.*SQR(dx[0]));
    coeff(+1,0) = -16./(12.*SQR(dx[0]));
    coeff(+2,0) =   1./(12.*SQR(dx[0]));

    coeff(0,-2) =   1./(12.*SQR(dx[1]));
    coeff(0,-1) = -16./(12.*SQR(dx[1]));
    coeff(0,+1) = -16./(12.*SQR(dx[1]));   
    coeff(0,+2) =   1./(12.*SQR(dx[1]));   

  }
  else if( orderOfAccuracy==6 )
  {
    // ----  -Delta : order=6 ----
    coeff(0,0)  =  490./(180.*SQR(dx[0])) + 490./(180.*SQR(dx[1]));

    coeff(-3,0) =   -2./(180.*SQR(dx[0]));
    coeff(-2,0) =   27./(180.*SQR(dx[0]));
    coeff(-1,0) = -270./(180.*SQR(dx[0]));
    coeff(+1,0) = -270./(180.*SQR(dx[0]));
    coeff(+2,0) =   27./(180.*SQR(dx[0]));
    coeff(+3,0) =   -2./(180.*SQR(dx[0]));

    coeff(0,-3) =   -2./(180.*SQR(dx[1]));
    coeff(0,-2) =   27./(180.*SQR(dx[1]));
    coeff(0,-1) = -270./(180.*SQR(dx[1]));
    coeff(0,+1) = -270./(180.*SQR(dx[1]));   
    coeff(0,+2) =   27./(180.*SQR(dx[1]));   
    coeff(0,+3) =   -2./(180.*SQR(dx[1]));   

  }  
else if( orderOfAccuracy==8 )
  {
    // ----  -Delta : order=8 ----
    coeff(0,0)  =  14350./(5040.*SQR(dx[0])) + 14350./(5040.*SQR(dx[1]));

    coeff(-4,0) =     9./(5040.*SQR(dx[0]));
    coeff(-3,0) =  -128./(5040.*SQR(dx[0]));
    coeff(-2,0) =  1008./(5040.*SQR(dx[0]));
    coeff(-1,0) = -8064./(5040.*SQR(dx[0]));
    coeff(+1,0) = -8064./(5040.*SQR(dx[0]));
    coeff(+2,0) =  1008./(5040.*SQR(dx[0]));
    coeff(+3,0) =  -128./(5040.*SQR(dx[0]));
    coeff(+4,0) =     9./(5040.*SQR(dx[0]));

    coeff(0,-4) =     9./(5040.*SQR(dx[1]));
    coeff(0,-3) =  -128./(5040.*SQR(dx[1]));
    coeff(0,-2) =  1008./(5040.*SQR(dx[1]));
    coeff(0,-1) = -8064./(5040.*SQR(dx[1]));
    coeff(0,+1) = -8064./(5040.*SQR(dx[1]));   
    coeff(0,+2) =  1008./(5040.*SQR(dx[1]));   
    coeff(0,+3) =  -128./(5040.*SQR(dx[1]));   
    coeff(0,+4) =     9./(5040.*SQR(dx[1]));   

  }    
  else
  {
    OV_ABORT("finish me - orderOfAccuracy");
  }

  ierr = MatCreate(PETSC_COMM_WORLD,&A);CHKERRQ(ierr);
  ierr = MatSetSizes(A,PETSC_DECIDE,PETSC_DECIDE,N,N);CHKERRQ(ierr);
  ierr = MatSetFromOptions(A);CHKERRQ(ierr);
  ierr = MatSetUp(A);CHKERRQ(ierr);

  ierr = MatGetOwnershipRange(A,&Istart,&Iend);CHKERRQ(ierr);



  Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
  Index Ibv[3], &Ib1=Ibv[0], &Ib2=Ibv[1], &Ib3=Ibv[2];
  Index Igv[3], &Ig1=Igv[0], &Ig2=Igv[1], &Ig3=Igv[2];
  int isv[3], &is1=isv[0], &is2=isv[1], &is3=isv[2];

  // ---- get interior points ----
  int extra=-1;
  getIndex(gid,I1,I2,I3,extra,extra,0);
  int ig0,ig;   

  if( !useNew )
  {
    for( int II=Istart; II<Iend; II++ ) 
    {
      int i = II/n; 
      int j = II-i*n;
      // printF("II=%d, i=%d, j=%d\n",II,i,j);

      if (i>0) {   ierr = MatSetValue(A,II,II-n,-dy2i,INSERT_VALUES);CHKERRQ(ierr); }
      if (i<m-1) { ierr = MatSetValue(A,II,II+n,-dy2i,INSERT_VALUES);CHKERRQ(ierr); }

      if (j>0) {   ierr = MatSetValue(A,II,II-1,-dx2i,INSERT_VALUES);CHKERRQ(ierr); }
      if (j<n-1) { ierr = MatSetValue(A,II,II+1,-dx2i,INSERT_VALUES);CHKERRQ(ierr); }

      ierr =              MatSetValue(A,II,II  , diag,INSERT_VALUES);CHKERRQ(ierr);

      // if (i>0) { ierr = MatSetValue(A,II,II-n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
      // if (i<m-1) { ierr = MatSetValue(A,II,II+n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
      // if (j>0) { ierr = MatSetValue(A,II,II-1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
      // if (j<n-1) { ierr = MatSetValue(A,II,II+1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
      // ierr = MatSetValue(A,II,II,4.0,INSERT_VALUES);CHKERRQ(ierr);

    }
  }
  else
  {

    // ---- interior points ----
    FOR_3D(i1,i2,i3,I1,I2,I3) 
    {
       getGlobalIndex( i1,i2,i3, ig0 );

       // printF("Interior: ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);

       // --- loop over stencil ---
       for( int iw2=-hw; iw2<=hw; iw2++ )
       {
         for( int iw1=-hw; iw1<=hw; iw1++ )
         {
           if( coeff(iw1,iw2) != 0. )
           {
              getGlobalIndex( i1+iw1,i2+iw2,i3, ig );
              ierr = MatSetValue(A,ig0,ig,coeff(iw1,iw2),INSERT_VALUES);CHKERRQ(ierr); 
            }
         }
       }
       // ierr = MatSetValue(A,ig0,ig0, diag,INSERT_VALUES);CHKERRQ(ierr);     
 
       // if( i1>n1a )
       // {
       //   getGlobalIndex( i1-1,i2,i3, ig );
       //   ierr = MatSetValue(A,ig0,ig,-dx2i,INSERT_VALUES);CHKERRQ(ierr); 
       // }
       // if( i1<n1b)
       // {
       //   getGlobalIndex( i1+1,i2,i3, ig );
       //   ierr = MatSetValue(A,ig0,ig,-dx2i,INSERT_VALUES);CHKERRQ(ierr); 
       // }       

       // if( i2>n2a )
       // {
       //   getGlobalIndex( i1,i2-1,i3, ig );
       //   ierr = MatSetValue(A,ig0,ig,-dy2i,INSERT_VALUES);CHKERRQ(ierr); 
       // }

       // if( i2<n2b )
       // {
       //   getGlobalIndex( i1,i2+1,i3, ig );
       //   ierr = MatSetValue(A,ig0,ig,-dy2i,INSERT_VALUES);CHKERRQ(ierr); 
       // }  


    }
    
    // --- fill in boundary points (constraints) ----
    ForBoundary(side,axis)
    {
      getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
      FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
      {
        getGlobalIndex( i1,i2,i3, ig0 );
        // printF("Boundary: ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);
        ierr = MatSetValue(A,ig0,ig0, 1.,INSERT_VALUES);CHKERRQ(ierr);  
      }          
    } 

    // --- fill in ghost points (constraints) ----
    ForBoundary(side,axis)
    {
      is1=is2=is3=0;
      isv[axis]=1-2*side;   // +1 on left and -1 on right 
      getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
      FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
      {
        for( int ghost=1; ghost<=numGhost; ghost++ )
        {
          int j1 = i1 -is1*ghost, j2 = i2 -is2*ghost,  j3 = i3;  // ghost point
          getGlobalIndex( j1,j2,j3, ig0 );
          // printF("Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);
          for( int k=0; k<=extrapOrder; k++ )
          {
            getGlobalIndex( j1+is1*k,j2+is2*k,j3, ig);
            ierr = MatSetValue(A,ig0,ig,extrapCoeff[k],INSERT_VALUES);CHKERRQ(ierr);  
          }
        }
      }          
    }  

    // --- fill corners ----
    for( int side2=0; side2<=1; side2++ ) 
    {
      for( int side1=0; side1<=1; side1++ ) 
      {
        is1=1-2*side1; is2=1-2*side2; is3=0;
        i1 = gid(side1,0); i2=gid(side2,1); i3=0; // corner point 
        for( int ghost2=1; ghost2<=numGhost; ghost2++ )
        {
          for( int ghost1=1; ghost1<=numGhost; ghost1++ )
          {
            int j1 = i1 -is1*ghost1, j2 = i2 -is2*ghost2, j3 = i3;  // ghost point
            getGlobalIndex( j1,j2,j3, ig0 );
            // printF("Corner Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);
            for( int k=0; k<=extrapOrder; k++ )
            {
              getGlobalIndex( j1+is1*k,j2+is2*k,j3, ig);
              ierr = MatSetValue(A,ig0,ig,extrapCoeff[k],INSERT_VALUES);CHKERRQ(ierr);  
            }            
          }
        }
      }
    }
  }


  ierr = MatAssemblyBegin(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  ierr = MatAssemblyEnd(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);



  // ----- MATRIX B = I -----

  ierr = MatCreate(PETSC_COMM_WORLD,&B);CHKERRQ(ierr);
  ierr = MatSetSizes(B,PETSC_DECIDE,PETSC_DECIDE,N,N);CHKERRQ(ierr);
  ierr = MatSetFromOptions(B);CHKERRQ(ierr);
  ierr = MatSetUp(B);CHKERRQ(ierr);

  ierr = MatGetOwnershipRange(B,&Istart,&Iend);CHKERRQ(ierr);
  if( !useNew )
  {
    for( int II=Istart; II<Iend; II++) 
    {
      int i = II/n; 
      int j = II-i*n;
      // if (i>0) { ierr = MatSetValue(B,II,II-n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
      // if (i<m-1) { ierr = MatSetValue(B,II,II+n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
      // if (j>0) { ierr = MatSetValue(B,II,II-1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
      // if (j<n-1) { ierr = MatSetValue(B,II,II+1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
      ierr = MatSetValue(B,II,II,1.0,INSERT_VALUES);CHKERRQ(ierr);
    }
  }
  else
  {
    // --- B(i,j) =1 : interior points ----
    getIndex(gid,I1,I2,I3,extra,extra,0);
    FOR_3D(i1,i2,i3,I1,I2,I3) 
    {
      getGlobalIndex( i1,i2,i3, ig0 );
      // printF("B ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);
      ierr = MatSetValue(B,ig0,ig0, 1.,INSERT_VALUES);CHKERRQ(ierr);      
    }
    if( true )
    {      
      // --- fill in boundary points (constraints) ----

      // FILL in a small value instead of zero
      real smallValue = tol; // 1.e-8; 

      ForBoundary(side,axis)
      {
        getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
        FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
        {
          getGlobalIndex( i1,i2,i3, ig0 );
          // printF("Boundary B: ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);
          ierr = MatSetValue(B,ig0,ig0, smallValue,INSERT_VALUES);CHKERRQ(ierr);  
        }          
      } 

      // --- fill in ghost points (constraints) ----
      ForBoundary(side,axis)
      {
        is1=is2=is3=0;
        isv[axis]=1-2*side;   // +1 on left and -1 on right 
        getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
        FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
        {
          for( int ghost=1; ghost<=numGhost; ghost++ )
          {
            int j1 = i1 -is1*ghost, j2 = i2 -is2*ghost,  j3 = i3;  // ghost point
            getGlobalIndex( j1,j2,j3, ig0 );
            // printF("B Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);
            ierr = MatSetValue(B,ig0,ig0, smallValue,INSERT_VALUES);CHKERRQ(ierr);             
          }
        }          
      }  

      // --- fill corners ----
      for( int side2=0; side2<=1; side2++ ) 
      {
        for( int side1=0; side1<=1; side1++ ) 
        {
          is1=1-2*side1; is2=1-2*side2; is3=0;
          i1 = gid(side1,0); i2=gid(side2,1); i3=0; // corner point 
          for( int ghost2=1; ghost2<=numGhost; ghost2++ )
          {
            for( int ghost1=1; ghost1<=numGhost; ghost1++ )
            {
              int j1 = i1 -is1*ghost1, j2 = i2 -is2*ghost2, j3 = i3;  // ghost point
              getGlobalIndex( j1,j2,j3, ig0 );
              // printF("B Corner Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);

              ierr = MatSetValue(B,ig0,ig0, smallValue,INSERT_VALUES);CHKERRQ(ierr);                  
            }
          }
        }
      }

    }   
  }

  ierr = MatAssemblyBegin(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  ierr = MatAssemblyEnd(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);

  return 0;
}


// ==================================================================================
// Compute the eigenvalues using SLEPc
// ==================================================================================
int
computeEigenvalues( int orderOfAccuracy, int numEigenValues, int numEigenVectors, 
                    RealArray & eig, realMappedGridFunction & u, Real tol )
{

  Mat            A,B;             /* matrices */
  EPS            eps;             /* eigenproblem solver context */
  EPSType        type;
  Vec            xr,xi,*Iv,*Cv;
  PetscInt       nev,maxit,i,its,lits,nconv,nini=0,ncon=0;
  char           filename[PETSC_MAX_PATH_LEN];
  PetscViewer    viewer;
  PetscBool      flg,evecs,ishermitian;
  PetscErrorCode ierr;

  // SlepcInitialize(&argc,&argv,(char*)0,help);


  PetscBool      flag;
  int j,N,m,n,Istart,Iend,II;

  // ierr = PetscOptionsGetInt(NULL,"-n",&n,NULL);CHKERRQ(ierr);
  // ierr = PetscOptionsGetInt(NULL,"-m",&m,&flag);CHKERRQ(ierr);
  // if (!flag) m=n;

  MappedGrid & mg = *u.getMappedGrid();
  const bool isRectangular = mg.isRectangular();
  real dx[3]={1.,1.,1.};
  if( isRectangular )
    mg.getDeltaX(dx);

  assert( isRectangular );

  const IntegerArray & gid = mg.gridIndexRange();
  n = gid(1,0)-gid(0,0)+1 - 2;
  m = gid(1,1)-gid(0,1)+1 - 2;

  // ----- Number of ghost points ----
  const int numGhost= orderOfAccuracy/2;


  const int nd1a = gid(1,0)-gid(0,0)+1 + 2*numGhost;
  const int nd2a = gid(1,1)-gid(0,1)+1 + 2*numGhost;
  const int n1a = gid(0,0)-numGhost;
  const int n2a = gid(0,1)-numGhost;
  const int n1b = gid(1,0)+numGhost;
  const int n2b = gid(1,1)+numGhost;  

  int i1,i2,i3;

  bool useNew=true;


  // N = n*m;
  N = nd1a*nd2a; // total number of grid points

  ierr = PetscPrintf(PETSC_COMM_WORLD,"\n Generalized Eigenavlue Problem Ax = k Bx, N=%D (%Dx%D grid)\n\n",N,n,m);CHKERRQ(ierr);



   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   //      Load the matrices that define the eigensystem, Ax=kBx
   //   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

//   ierr = PetscPrintf(PETSC_COMM_WORLD,"\nGeneralized eigenproblem stored in file.\n\n");CHKERRQ(ierr);
//   ierr = PetscOptionsGetString(NULL,"-f1",filename,PETSC_MAX_PATH_LEN,&flg);CHKERRQ(ierr);
//   if (!flg) SETERRQ(PETSC_COMM_WORLD,1,"Must indicate a file name for matrix A with the -f1 option");

// #if defined(PETSC_USE_COMPLEX)
//   ierr = PetscPrintf(PETSC_COMM_WORLD," Reading COMPLEX matrices from binary files...\n");CHKERRQ(ierr);
// #else
//   ierr = PetscPrintf(PETSC_COMM_WORLD," Reading REAL matrices from binary files...\n");CHKERRQ(ierr);
// #endif
//   ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_READ,&viewer);CHKERRQ(ierr);
//   ierr = MatCreate(PETSC_COMM_WORLD,&A);CHKERRQ(ierr);
//   ierr = MatSetFromOptions(A);CHKERRQ(ierr);
//   ierr = MatLoad(A,viewer);CHKERRQ(ierr);
//   ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);

//   ierr = PetscOptionsGetString(NULL,"-f2",filename,PETSC_MAX_PATH_LEN,&flg);CHKERRQ(ierr);
//   if (flg) {
//     ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_READ,&viewer);CHKERRQ(ierr);
//     ierr = MatCreate(PETSC_COMM_WORLD,&B);CHKERRQ(ierr);
//     ierr = MatSetFromOptions(B);CHKERRQ(ierr);
//     ierr = MatLoad(B,viewer);CHKERRQ(ierr);
//     ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
//   } else {
//     ierr = PetscPrintf(PETSC_COMM_WORLD," Matrix B was not provided, setting B=I\n\n");CHKERRQ(ierr);
//     B = NULL;
//   }


  // ---- Fill Matrix A and B for the minus Laplacian ----
  fillMatrixLaplacian( orderOfAccuracy, mg, A, B, numGhost, useNew, tol );

  // // ----- MATRIX A -----

  // ierr = MatCreate(PETSC_COMM_WORLD,&A);CHKERRQ(ierr);
  // ierr = MatSetSizes(A,PETSC_DECIDE,PETSC_DECIDE,N,N);CHKERRQ(ierr);
  // ierr = MatSetFromOptions(A);CHKERRQ(ierr);
  // ierr = MatSetUp(A);CHKERRQ(ierr);

  // ierr = MatGetOwnershipRange(A,&Istart,&Iend);CHKERRQ(ierr);

  // Real dx2i = 1./(dx[0]*dx[0]);
  // Real dy2i = 1./(dx[1]*dx[1]);
  // Real diag = 2.*dx2i + 2.*dy2i; 
  // for (II=Istart;II<Iend;II++) {
  //   i = II/n; j = II-i*n;
  //   if (i>0) {   ierr = MatSetValue(A,II,II-n,-dy2i,INSERT_VALUES);CHKERRQ(ierr); }
  //   if (i<m-1) { ierr = MatSetValue(A,II,II+n,-dy2i,INSERT_VALUES);CHKERRQ(ierr); }

  //   if (j>0) {   ierr = MatSetValue(A,II,II-1,-dx2i,INSERT_VALUES);CHKERRQ(ierr); }
  //   if (j<n-1) { ierr = MatSetValue(A,II,II+1,-dx2i,INSERT_VALUES);CHKERRQ(ierr); }

  //   ierr =              MatSetValue(A,II,II  , diag,INSERT_VALUES);CHKERRQ(ierr);

  //   // if (i>0) { ierr = MatSetValue(A,II,II-n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (i<m-1) { ierr = MatSetValue(A,II,II+n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (j>0) { ierr = MatSetValue(A,II,II-1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (j<n-1) { ierr = MatSetValue(A,II,II+1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // ierr = MatSetValue(A,II,II,4.0,INSERT_VALUES);CHKERRQ(ierr);

  // }

  // ierr = MatAssemblyBegin(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  // ierr = MatAssemblyEnd(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);



  // // ----- MATRIX B = I -----

  // ierr = MatCreate(PETSC_COMM_WORLD,&B);CHKERRQ(ierr);
  // ierr = MatSetSizes(B,PETSC_DECIDE,PETSC_DECIDE,N,N);CHKERRQ(ierr);
  // ierr = MatSetFromOptions(B);CHKERRQ(ierr);
  // ierr = MatSetUp(B);CHKERRQ(ierr);

  // ierr = MatGetOwnershipRange(B,&Istart,&Iend);CHKERRQ(ierr);
  // for (II=Istart;II<Iend;II++) {
  //   i = II/n; j = II-i*n;
  //   // if (i>0) { ierr = MatSetValue(B,II,II-n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (i<m-1) { ierr = MatSetValue(B,II,II+n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (j>0) { ierr = MatSetValue(B,II,II-1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (j<n-1) { ierr = MatSetValue(B,II,II+1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   ierr = MatSetValue(B,II,II,1.0,INSERT_VALUES);CHKERRQ(ierr);
  // }

  // ierr = MatAssemblyBegin(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  // ierr = MatAssemblyEnd(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);



  ierr = MatGetVecs(A,NULL,&xr);CHKERRQ(ierr);
  ierr = MatGetVecs(A,NULL,&xi);CHKERRQ(ierr);

  /*
     Read user constraints if available
  */
  ierr = PetscOptionsGetInt(NULL,"-nconstr",&ncon,&flg);CHKERRQ(ierr);
  if (flg) {
    if (ncon<=0) SETERRQ(PETSC_COMM_WORLD,1,"The number of constraints must be >0");
    ierr = PetscOptionsGetString(NULL,"-fconstr",filename,PETSC_MAX_PATH_LEN,&flg);CHKERRQ(ierr);
    if (!flg) SETERRQ(PETSC_COMM_WORLD,1,"Must specify the name of the file storing the constraints");
    ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_READ,&viewer);CHKERRQ(ierr);
    ierr = VecDuplicateVecs(xr,ncon,&Cv);CHKERRQ(ierr);
    for (i=0;i<ncon;i++) {
      ierr = VecLoad(Cv[i],viewer);CHKERRQ(ierr);
    }
    ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
  }

  /*
     Read initial guesses if available
  */
  ierr = PetscOptionsGetInt(NULL,"-ninitial",&nini,&flg);CHKERRQ(ierr);
  if (flg) {
    if (nini<=0) SETERRQ(PETSC_COMM_WORLD,1,"The number of initial vectors must be >0");
    ierr = PetscOptionsGetString(NULL,"-finitial",filename,PETSC_MAX_PATH_LEN,&flg);CHKERRQ(ierr);
    if (!flg) SETERRQ(PETSC_COMM_WORLD,1,"Must specify the name of the file containing the initial vectors");
    ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_READ,&viewer);CHKERRQ(ierr);
    ierr = VecDuplicateVecs(xr,nini,&Iv);CHKERRQ(ierr);
    for (i=0;i<nini;i++) {
      ierr = VecLoad(Iv[i],viewer);CHKERRQ(ierr);
    }
    ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                Create the eigensolver and set various options
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /*
     Create eigensolver context
  */
  ierr = EPSCreate(PETSC_COMM_WORLD,&eps);CHKERRQ(ierr);

  /*
     Set operators. In this case, it is a generalized eigenvalue problem
  */
  ierr = EPSSetOperators(eps,A,B);CHKERRQ(ierr);

  /*
     If the user provided initial guesses or constraints, pass them here
  */
  ierr = EPSSetInitialSpace(eps,nini,Iv);CHKERRQ(ierr);
  ierr = EPSSetDeflationSpace(eps,ncon,Cv);CHKERRQ(ierr);

  PetscInt maxIt = 1000; 
  ierr = EPSSetTolerances(eps,tol,maxIt); CHKERRQ(ierr);

  /*
     Set solver parameters at runtime
  */
  ierr = EPSSetFromOptions(eps);CHKERRQ(ierr);

  PetscInt mpd = PETSC_DEFAULT; // numEigenVectors; // maximum projected dimension, decrease to save space
  printF("Setting numEigenValues=%d, numEigenVectors=%d,\n",numEigenValues,numEigenVectors);
  PetscInt ncv = PETSC_DEFAULT; // numEigenValues*2+1; // size of column space 
  ierr = EPSSetDimensions(eps,numEigenValues,ncv,mpd); CHKERRQ(ierr);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                      Solve the eigensystem
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  ierr = EPSSolve(eps);CHKERRQ(ierr);

  /*
     Optional: Get some information from the solver and display it
  */
  ierr = EPSGetIterationNumber(eps,&its);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD," Number of iterations of the method: %D\n",its);CHKERRQ(ierr);
  ierr = EPSGetOperationCounters(eps,NULL,NULL,&lits);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD," Number of linear iterations of the method: %D\n",lits);CHKERRQ(ierr);
  ierr = EPSGetType(eps,&type);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD," Solution method: %s\n\n",type);CHKERRQ(ierr);

  ierr = EPSGetDimensions(eps,&nev,NULL,NULL);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD," Number of requested eigenvalues: %D\n",nev);CHKERRQ(ierr);

  nev = numEigenValues;

  ierr = EPSGetTolerances(eps,&tol,&maxit);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD," Stopping condition: tol=%.4G, maxit=%D\n",tol,maxit);CHKERRQ(ierr);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                    Display solution and clean up
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  ierr = EPSPrintSolution(eps,NULL);CHKERRQ(ierr);
  /*
     Save eigenvectors, if requested
  */
  ierr = PetscOptionsGetString(NULL,"-evecs",filename,PETSC_MAX_PATH_LEN,&evecs);CHKERRQ(ierr);

  ierr = EPSGetConverged(eps,&nconv);CHKERRQ(ierr);
  if( nconv>0 && nev>0 ) 
  {
    // ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_WRITE,&viewer);CHKERRQ(ierr);
    // ierr = EPSIsHermitian(eps,&ishermitian);CHKERRQ(ierr);
    // for (i=0;i<nconv;i++) 
    eig.redim(2,numEigenVectors);

    for( int i=0; i<numEigenVectors; i++ ) 
    {

      PetscScalar kr, ki;
      ierr = EPSGetEigenpair(eps,i,&kr,&ki,xr,xi); CHKERRQ(ierr);
      eig(0,i) = kr;
      eig(1,i) = ki;

      // printF("Eigenvalue %d : k=%18.14e + %18.14e I \n",i,kr,ki);

      // ierr = EPSGetEigenvector(eps,i,xr,xi);CHKERRQ(ierr);

      // ierr = VecView(xr,viewer);CHKERRQ(ierr);
      // if (!ishermitian) { ierr = VecView(xi,viewer);CHKERRQ(ierr); }

      if( i<numEigenVectors )
      {
        // ---- Save the first eigenvector ----
        // printF("Save eigenvector %d to the grid function.\n",i);

        PetscScalar *xrv;
        VecGetArray(xr,&xrv);  // get the local array from Petsc
        ierr = VecGetOwnershipRange(xr,&Istart,&Iend);CHKERRQ(ierr);

        if( useNew )
        {
          for(int II=Istart; II<Iend; II++ ) 
          {
            getLocalIndex( II,i1,i2,i3 ); 
            // printF("II=%d, i1=%d, i2=%d\n",II,i1,i2);

            assert( i1>=n1a && i1<=n1b && i2>=n2a && i2<=n2b );
            u(i1,i2,i3,i) = xrv[II];
          }
        }
        else
        {
          for (int II=Istart; II<Iend; II++) 
          {
            // II = i1 + n*( i2 )
            int i2 = II/n, i1 = II-i2*n, i3=0;
            // printF("II=%d: i1=%i, i2=%d\n",II,i1,i2);
            assert( i1<u.getBound(0) && i2<u.getBound(1) );
            u(i1+1,i2+1,i3,i) = xrv[II];
          }          

        }
      }
    }
    // ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
  }

  /*
     Free work space
  */
  ierr = EPSDestroy(&eps);CHKERRQ(ierr);
  ierr = MatDestroy(&A);CHKERRQ(ierr);
  ierr = MatDestroy(&B);CHKERRQ(ierr);
  ierr = VecDestroy(&xr);CHKERRQ(ierr);
  ierr = VecDestroy(&xi);CHKERRQ(ierr);
  if (nini > 0) {
    ierr = VecDestroyVecs(nini,&Iv);CHKERRQ(ierr);
  }
  if (ncon > 0) {
    ierr = VecDestroyVecs(ncon,&Cv);CHKERRQ(ierr);
  }
  // ierr = SlepcFinalize();


}// end compute Eigenvalues 



#undef __FUNCT__
#define __FUNCT__ "main"
int main(int argc,char **argv)
{

  Overture::start(argc,argv);  // initialize Overture

  SlepcInitialize(&argc,&argv,(char*)0,help);  

  aString commandFileName="";
  bool plotOption=true;
  int debug=0;
  int numPoints=101;
  int nx=52, ny=52; 
  int numEigenValues  = 1; // number of eigenvalues to compute 
  int numEigenVectors = 1; // number of eigenvectors to save
  int orderOfAccuracy = 2 ;
  real tol=1.e-8; 

  printF("Usage: genEigs [-debug=<i>]\n");
  int len=0;
  if( argc > 1 )
  { 
    for( int i=1; i<argc; i++ )
    {
      aString arg = argv[i];
      if( arg=="-noplot" || arg=="noplot" )
        plotOption=false;
      else if( arg(0,6)=="-debug=" )
      {
        sScanF(arg(7,arg.length()-1),"%i",&debug);
        printF("Setting debug=%i\n",debug);
      }
      else if( (len=arg.matches("-orderOfAccuracy="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&orderOfAccuracy);
        printF("Setting orderOfAccuracy=%d\n",orderOfAccuracy);
      }
      else if( (len=arg.matches("-order="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&orderOfAccuracy);
        printF("Setting orderOfAccuracy=%d\n",orderOfAccuracy);
      }      

      else if( (len=arg.matches("-nx="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&nx);
        printF("Setting nx=%d\n",nx);
      }

      else if( (len=arg.matches("-tol="))  )
      {
        sScanF(arg(len,arg.length()-1),"%e",&tol);
        printF("Setting tol=%e\n",tol);
      }

      else if( (len=arg.matches("-ny="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&ny);
        printF("Setting ny=%d\n",ny);
      }
      else if( (len=arg.matches("-numEigenValues="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&numEigenValues);
        printF("Setting numEigenValues=%d\n",numEigenValues);
      }          
      else if( (len=arg.matches("-numEigenVectors="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&numEigenVectors);
        printF("Setting numEigenVectors=%d\n",numEigenVectors);
      }         
      else if( commandFileName=="" )
      {
        commandFileName=arg;    
        printf("genEigs: reading commands from file [%s]\n",(const char*)commandFileName);
      }
    }
  }
  else
  {
    printF("Usage: `genEigs [-noplot] [-g=<gridName>] [file.cmd] [-debug=<value>] ' \n");
  }
  
  GenericGraphicsInterface & gi = *Overture::getGraphicsInterface("genEigs",plotOption,argc,argv);
  PlotStuffParameters psp;

  // By default start saving the command file called:
  aString logFile="genEigs.cmd";
  gi.saveCommandFile(logFile);
  printF("User commands are being saved in the file `%s'\n",(const char *)logFile);

  aString outputFileName="genEigs.log";
  FILE *outFile = NULL;
  

  // read from a command file if given
  if( commandFileName!="" )
  {
    printF("read command file =[%s].\n",(const char*)commandFileName);
    gi.readCommandFile(commandFileName);
  }


  int numGhost = orderOfAccuracy/2;

  const int numberOfDimensions=2;

  SquareMapping square(0.,1.,0.,1.);                   // Make a mapping, unit square
  square.setGridDimensions(axis1,nx);                  // axis1==0, set no. of grid points
  square.setGridDimensions(axis2,ny);                  // axis2==1, set no. of grid points

  MappedGrid mg(square);   
  ForBoundary(side,axis)
  {
    mg.setNumberOfGhostPoints(side,axis,numGhost);
  }                             
  mg.update(MappedGrid::THEmask | MappedGrid::THEvertex | MappedGrid::THEcenter);    
  
  Range all;                                   // a null Range is used as a place-holder below for the coordinates
  realMappedGridFunction u(mg,all,all,all,numEigenVectors);  // create a grid function
  u.setName("v");                 // give names to grid function ...
  for( int i=0; i<numEigenVectors; i++ )
  {
    u.setName(sPrintF("v%d",i),i);
  }
  Index I1,I2,I3; 
  getIndex(mg.dimension(),I1,I2,I3);                        // assign I1,I2,I3 from dimension

  u=0.;
  // u(I1,I2,I3,0)=sin(Pi*mg.vertex()(I1,I2,I3,axis1))         // component 0 : sin(pi*x)*cos(pi*y)
  //              *cos(Pi*mg.vertex()(I1,I2,I3,axis2));        
  // u(I1,I2,I3,1)=cos(Pi*mg.vertex()(I1,I2,I3,axis1))         // component 1 : cos(pi*x)*sin(pi*y)
  //              *sin(Pi*mg.vertex()(I1,I2,I3,axis2));       


  // // Create the object that knows how to evaluate the boundary of the eye-lid
  // EyeCurves eyeCurves;
  
  real time=0.; // plot curve at this time
  
  // ========== create the GUI and dialog ================
  GUIState dialog;
  dialog.setWindowTitle("Eigenvalues Code");
  dialog.setExitCommand("exit", "exit");

  aString cmds[] = {"compute",
                    "contour",
                    "movie",
                    "erase",
                    "save file",
                    "" };
  int numberOfPushButtons=0;  // number of entries in cmds
  while( cmds[numberOfPushButtons]!="" ){numberOfPushButtons++;}; // 
  int numRows=(numberOfPushButtons+1)/2;
  dialog.setPushButtons( cmds, cmds, numRows ); 

  const int numberOfTextStrings=15;  // max number allowed
  aString textLabels[numberOfTextStrings];
  aString textStrings[numberOfTextStrings];

  int nt=0;
  textLabels[nt] = "time:";  sPrintF(textStrings[nt],"%g",time);  nt++; 
  textLabels[nt] = "numPoints:";  sPrintF(textStrings[nt],"%i",numPoints);  nt++; 
  // null strings terminal list
  textLabels[nt]="";   textStrings[nt]="";  assert( nt<numberOfTextStrings );
  dialog.setTextBoxes(textLabels, textLabels, textStrings);

  gi.pushGUI(dialog);
  gi.appendToTheDefaultPrompt("genEigs>");
  psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,true);

  RealArray eig; 
 
  aString answer,buff;  
  for( ;; )
  {
    gi.getAnswer(answer,"");  
 
    if( answer=="continue" )
    {
      break;
    }
    else if( answer=="exit" || answer=="done" )
    {
      break;
    }
    else if( answer=="compute" )
    {
      computeEigenvalues( orderOfAccuracy, numEigenValues,numEigenVectors, eig, u, tol );

      for( int i=0; i<numEigenVectors; i++ )
      {
        printF("Eigenvalue %d : k=%18.14e + %18.14e I",i,eig(0,i),eig(1,i));
        if( i<=6 )
        {
          // --- Eigenvalues of the -Laplacian on the unit square ---
          real eigTrue = i==0 ? 2*Pi*Pi : 
                         i==1 ? SQR(Pi) + SQR(2.*Pi) :
                         i==2 ? SQR(Pi) + SQR(2.*Pi) : 
                         i==3 ? SQR(2.*Pi) + SQR(2.*Pi) :
                         i==4 ? SQR(3.*Pi) + SQR(1.*Pi) :
                         i==5 ? SQR(3.*Pi) + SQR(1.*Pi) :
                                SQR(2.*Pi) + SQR(3.*Pi) ;
          printF(",  true=%18.14e, err=%8.2e",eigTrue,fabs(eig(0,i)-eigTrue));
        }
        printF("\n");
      }
    }    
    else if( answer=="contour" )
    {
      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,false);      
      psp.set(GI_TOP_LABEL,sPrintF("Eigenvector"));  // set title
      PlotIt::contour(gi, u,psp );
      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,true);      
    }    
    else if( dialog.getTextValue(answer,"time:","%g",time) ){}// 
    else if( dialog.getTextValue(answer,"numPoints:","%i",numPoints) ){}// 
    else if( answer=="erase" )
    {
      gi.erase();
    }
    // else if( answer=="movie" )
    // {
    //   // --- plot a movie of the eye motion ---

    //   // fix the plot bounds as the eye moves 
    //   RealArray xBound(2,3);
    //   xBound(0,0)=-1.2; xBound(1,0)= 1.2;
    //   xBound(0,1)=-1.2; xBound(1,1)= 1.2;
    //   xBound(0,2)=-1.;  xBound(1,2)= 1.;

    //   real dt=.005*Pi, tFinal=10*Pi;
    //   int nStep=int( tFinal/dt + .5 );
    //   dt = tFinal/(nStep);

    //   real yMax=-1.e10; // keep track of the largest y value of the eye-lid 

    //   RealArray x;
    //   for( int step=0; step<nStep; step++ )
    //   {
    //     real t=step*dt;
        
    //     eyeCurves.getEyeCurve( x,t,numPoints );

    //     Range R = x.dimension(0);
    //     real yTop = max(x(R,1));
    //     if( yTop>yMax )
    //     {
    //       yMax=yTop;
    //     }
    //     else if( yTop>yMax*(.99999) )
    //     {
    //       printF("Eye reaches yMax=%9.3e at t=%9.3e t/(2*pi)=%9.3e\n",yMax,t,t/twoPi);
    //     }
        
    //     gi.erase();
    //     psp.set(GI_TOP_LABEL,sPrintF(buff,"genEigs: t=%9.2e, yMax=%8.2e",t,yMax));
    //     plotCurve( x, gi,psp );
    //     gi.setGlobalBound(xBound); // set plot bounds         

    //     gi.redraw(true);
    //   }

    // }

    // else if( answer=="save file" )
    // {
    //   aString fileName = "eyeCurveDataPoints.dat";
    //   eyeCurves.saveEyeCurve( time, numPoints, fileName );
    //   printF("Eye coordinates written to file=[%s]\n",(const char*)fileName);
    // }
    
    else
    {
      printF("Unknown response=[%s]\n",(const char*)answer);
    }
  }
  

  gi.unAppendTheDefaultPrompt();
  gi.popGUI(); // restore the previous GUI


  int ierr = SlepcFinalize();

  Overture::finish();  

  return 0;
}

