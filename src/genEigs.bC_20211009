// ==================================================================================================
// Solve a generalized eigenvalue problem with SLEPc
//            A x = k B x
// 
// Started from SLEPc examples:
//      src/eps/examples/tutorials/ex2.c  : Laplace
//      src/eps/examples/tutorials/ex7.c  : generalized eig problem, read matrices from files
// ==================================================================================================






static char help[] = "Compute some  eigenvalues\n";

#include <slepceps.h>

#include "Overture.h"
#include "display.h"
#include "PlotStuff.h"  
#include "SquareMapping.h" 
#include "Ogshow.h"

#include "CompositeGridOperators.h"
#include "SparseRep.h" 
#include "Oges.h"
#include "ParallelUtility.h"
#include "gridFunctionNorms.h"

// Boundary conditions:
const int periodic=-1, interpolation=0, displacement=1, traction=2;

#define FOR_3D(i1,i2,i3,I1,I2,I3) \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(int i3=I3Base; i3<=I3Bound; i3++) \
for(int i2=I2Base; i2<=I2Bound; i2++) \
for(int i1=I1Base; i1<=I1Bound; i1++)  

#define FOR_3(i1,i2,i3,I1,I2,I3) \
I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(int i3=I3Base; i3<=I3Bound; i3++) \
for(int i2=I2Base; i2<=I2Bound; i2++) \
for(int i1=I1Base; i1<=I1Bound; i1++)  

#define ForBoundary(side,axis)   for( int axis=0; axis<numberOfDimensions; axis++ ) \
                                 for( int side=0; side<=1; side++ )  

// ============================================================================
// Compute the global matrix index ig from the grid-function index (i1,i2,i3,n)
// ===========================================================================
#beginMacro getGlobalIndex(i1,i2,i3,n,ig)
  ig = (i1)-n1a + nd1a*( (i2)-n2a + nd2a*(n) );
  assert( ig>=0 && ig<N );
#endMacro

// =================================================================================
// Compute the local grid-function index (i1,i2,i3,n) from the global matrix index ig
// ================================================================================
#beginMacro getLocalIndex( ig,i1,i2,i3,n )
   i3 = 0;
   n = ig/(nd1a*nd2a); 
   i2 = n2a + (ig- nd1a*nd2a*(n) )/nd1a;
   i1 = ig + n1a - nd1a*( (i2)-n2a + nd2a*(n) );
#endMacro

#beginMacro printMatrixEntry(ig0,ig,val,label)
  if( printEntries )
  {
    printF(" ig0=%4d ig=%4d value=%10.3f (label)\n",ig0,ig,val);
  }
#endMacro

// ==================================================================================
// Fill in the PETSc matrices A and B 
//          minus-Laplacian 
// ==================================================================================
int
fillMatrixLaplacian( int orderOfAccuracy, MappedGrid & mg, Mat & A, Mat & B, int numGhost, bool useNew, 
                     Real tol, int eigOption, IntegerArray & bc, int saveMatlab )
{

  PetscBool flag;
  int Istart,Iend,ierr;

  const int numberOfDimensions = mg.numberOfDimensions();

  const bool isRectangular = mg.isRectangular();
  real dx[3]={1.,1.,1.};
  if( isRectangular )
    mg.getDeltaX(dx);

  assert( isRectangular );

  const IntegerArray & gid = mg.gridIndexRange();

  // No boundary points: 
  // int n = gid(1,0)-gid(0,0)+1 - 2;
  // int m = gid(1,1)-gid(0,1)+1 - 2;

  const int nd1a = gid(1,0)-gid(0,0)+1 + 2*numGhost;
  const int nd2a = gid(1,1)-gid(0,1)+1 + 2*numGhost;

  const int n1a = gid(0,0)-numGhost;
  const int n2a = gid(0,1)-numGhost;

  const int n1b = gid(1,0)+numGhost;
  const int n2b = gid(1,1)+numGhost;

  int numberOfComponents=1; 
  const int N = nd1a*nd2a*numberOfComponents; // total number of grid points

  // int orderOfAccuracy=2;
  const int extrapOrder = orderOfAccuracy+1;

  const Real extraplapCoeff3[] = {1.,-3.,3.,-1.};
  const Real extraplapCoeff4[] = {1.,-4.,6.,-4.,1.};
  const Real extraplapCoeff5[] = {1.,-5.,10.,-10.,5.,-1.};
  const Real extraplapCoeff6[] = {1.,-6.,15.,-20.,15.,-6.,1.};
  const Real extraplapCoeff7[] = {1.,-7.,21.,-35.,35.,-21.,7.,-1.};
  const Real extraplapCoeff8[] = {1.,-8.,28.,-56.,70.,-56.,28.,-8.,1.};
  const Real extraplapCoeff9[] = {1.,-9.,36.,-84.,126.,-126.,84.,-36.,9.,-1.};
  const Real *extraplapCoeff;
  if( extrapOrder==3 )
    extraplapCoeff = extraplapCoeff3;
  else if( extrapOrder==4 )
    extraplapCoeff = extraplapCoeff4;
  else if( extrapOrder==5 )
    extraplapCoeff = extraplapCoeff5;
  else if( extrapOrder==6 )
    extraplapCoeff = extraplapCoeff6;
  else if( extrapOrder==7 )
    extraplapCoeff = extraplapCoeff7;    
  else if( extrapOrder==8 )
    extraplapCoeff = extraplapCoeff8;     
  else if( extrapOrder==9 )
    extraplapCoeff = extraplapCoeff9;               
  else
   {
    printF("fillMatrixLaplacian:: unexpected extrapOrder=%d\n",extrapOrder);
    OV_ABORT("ERROR");
   }

  int i1,i2,i3;

  // int N = n*m;
  // int N = nd1a*nd2a;

  // ----- MATRIX A -----

  Real dx2i = 1./(dx[0]*dx[0]);
  Real dy2i = 1./(dx[1]*dx[1]);
  Real diag = 2.*dx2i + 2.*dy2i; 

  int hw = orderOfAccuracy/2; // stencil half with
  Range S(-hw,hw); // stencil
  RealArray lapCoeff(S,S);
  lapCoeff=0.;
  if( orderOfAccuracy==2 )
  {
    // ----  -Delta : order=2 ----
    lapCoeff(0,0)  =  2./SQR(dx[0]) + 2./SQR(dx[1]);

    lapCoeff(-1,0) = -1./SQR(dx[0]);
    lapCoeff(+1,0) = -1./SQR(dx[0]);

    lapCoeff(0,-1) = -1./SQR(dx[1]);
    lapCoeff(0,+1) = -1./SQR(dx[1]);    
  }
  else if( orderOfAccuracy==4 )
  {
    // ----  -Delta : order=4 ----
    lapCoeff(0,0)  =  30./(12.*SQR(dx[0])) + 30./(12.*SQR(dx[1]));

    lapCoeff(-2,0) =   1./(12.*SQR(dx[0]));
    lapCoeff(-1,0) = -16./(12.*SQR(dx[0]));
    lapCoeff(+1,0) = -16./(12.*SQR(dx[0]));
    lapCoeff(+2,0) =   1./(12.*SQR(dx[0]));

    lapCoeff(0,-2) =   1./(12.*SQR(dx[1]));
    lapCoeff(0,-1) = -16./(12.*SQR(dx[1]));
    lapCoeff(0,+1) = -16./(12.*SQR(dx[1]));   
    lapCoeff(0,+2) =   1./(12.*SQR(dx[1]));   

  }
  else if( orderOfAccuracy==6 )
  {
    // ----  -Delta : order=6 ----
    lapCoeff(0,0)  =  490./(180.*SQR(dx[0])) + 490./(180.*SQR(dx[1]));

    lapCoeff(-3,0) =   -2./(180.*SQR(dx[0]));
    lapCoeff(-2,0) =   27./(180.*SQR(dx[0]));
    lapCoeff(-1,0) = -270./(180.*SQR(dx[0]));
    lapCoeff(+1,0) = -270./(180.*SQR(dx[0]));
    lapCoeff(+2,0) =   27./(180.*SQR(dx[0]));
    lapCoeff(+3,0) =   -2./(180.*SQR(dx[0]));

    lapCoeff(0,-3) =   -2./(180.*SQR(dx[1]));
    lapCoeff(0,-2) =   27./(180.*SQR(dx[1]));
    lapCoeff(0,-1) = -270./(180.*SQR(dx[1]));
    lapCoeff(0,+1) = -270./(180.*SQR(dx[1]));   
    lapCoeff(0,+2) =   27./(180.*SQR(dx[1]));   
    lapCoeff(0,+3) =   -2./(180.*SQR(dx[1]));   

  }  
  else if( orderOfAccuracy==8 )
  {
    // ----  -Delta : order=8 ----
    lapCoeff(0,0)  =  14350./(5040.*SQR(dx[0])) + 14350./(5040.*SQR(dx[1]));

    lapCoeff(-4,0) =     9./(5040.*SQR(dx[0]));
    lapCoeff(-3,0) =  -128./(5040.*SQR(dx[0]));
    lapCoeff(-2,0) =  1008./(5040.*SQR(dx[0]));
    lapCoeff(-1,0) = -8064./(5040.*SQR(dx[0]));
    lapCoeff(+1,0) = -8064./(5040.*SQR(dx[0]));
    lapCoeff(+2,0) =  1008./(5040.*SQR(dx[0]));
    lapCoeff(+3,0) =  -128./(5040.*SQR(dx[0]));
    lapCoeff(+4,0) =     9./(5040.*SQR(dx[0]));

    lapCoeff(0,-4) =     9./(5040.*SQR(dx[1]));
    lapCoeff(0,-3) =  -128./(5040.*SQR(dx[1]));
    lapCoeff(0,-2) =  1008./(5040.*SQR(dx[1]));
    lapCoeff(0,-1) = -8064./(5040.*SQR(dx[1]));
    lapCoeff(0,+1) = -8064./(5040.*SQR(dx[1]));   
    lapCoeff(0,+2) =  1008./(5040.*SQR(dx[1]));   
    lapCoeff(0,+3) =  -128./(5040.*SQR(dx[1]));   
    lapCoeff(0,+4) =     9./(5040.*SQR(dx[1]));   

  }    
  else
  {
    OV_ABORT("finish me - orderOfAccuracy");
  }

  ierr = MatCreate(PETSC_COMM_WORLD,&A);CHKERRQ(ierr);
  ierr = MatSetSizes(A,PETSC_DECIDE,PETSC_DECIDE,N,N);CHKERRQ(ierr);
  ierr = MatSetFromOptions(A);CHKERRQ(ierr);
  ierr = MatSetUp(A);CHKERRQ(ierr);

  ierr = MatGetOwnershipRange(A,&Istart,&Iend);CHKERRQ(ierr);



  Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
  Index Ibv[3], &Ib1=Ibv[0], &Ib2=Ibv[1], &Ib3=Ibv[2];
  Index Igv[3], &Ig1=Igv[0], &Ig2=Igv[1], &Ig3=Igv[2];
  int isv[3], &is1=isv[0], &is2=isv[1], &is3=isv[2];

  // ---- get interior points ----
  int extra=-1;
  getIndex(gid,I1,I2,I3,extra,extra,0);
  int ig0,ig;   



  // ---- interior points ----
  int n=0; // component number 
  FOR_3D(i1,i2,i3,I1,I2,I3) 
  {
     getGlobalIndex( i1,i2,i3,n, ig0 );

     // printF("Interior: ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);

     // --- loop over stencil ---
     for( int iw2=-hw; iw2<=hw; iw2++ )
     {
       for( int iw1=-hw; iw1<=hw; iw1++ )
       {
         if( lapCoeff(iw1,iw2) != 0. )
         {
            getGlobalIndex( i1+iw1,i2+iw2,i3,n, ig );
            ierr = MatSetValue(A,ig0,ig,lapCoeff(iw1,iw2),INSERT_VALUES);CHKERRQ(ierr);

          }
       }
     }
  }
    
  // --- fill in boundary points (constraints) ----
  ForBoundary(side,axis)
  {
    getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
    FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
    {
      getGlobalIndex( i1,i2,i3,n, ig0 );
      // printF("Boundary: ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);
      ierr = MatSetValue(A,ig0,ig0, 1.,INSERT_VALUES);CHKERRQ(ierr);  
    }          
  } 

  // --- fill in ghost points (constraints) ----
  ForBoundary(side,axis)
  {
    is1=is2=is3=0;  isv[axis]=1-2*side;   // +1 on left and -1 on right 
    getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
    FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
    {
      for( int ghost=1; ghost<=numGhost; ghost++ )
      {
        int j1 = i1 -is1*ghost, j2 = i2 -is2*ghost,  j3 = i3;  // ghost point
        getGlobalIndex( j1,j2,j3,n, ig0 );
        // printF("Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);
        for( int k=0; k<=extrapOrder; k++ )
        {
          getGlobalIndex( j1+is1*k,j2+is2*k,j3,n, ig);
          ierr = MatSetValue(A,ig0,ig,extraplapCoeff[k],INSERT_VALUES);CHKERRQ(ierr);  
        }
      }
    }          
  }
  // --- fill corners ----
  for( int side2=0; side2<=1; side2++ ) 
  {
    for( int side1=0; side1<=1; side1++ ) 
    {
      is1=1-2*side1; is2=1-2*side2; is3=0;
      i1 = gid(side1,0); i2=gid(side2,1); i3=0; // corner point 
      for( int ghost2=1; ghost2<=numGhost; ghost2++ )
      {
        for( int ghost1=1; ghost1<=numGhost; ghost1++ )
        {
          int j1 = i1 -is1*ghost1, j2 = i2 -is2*ghost2, j3 = i3;  // ghost point
          getGlobalIndex( j1,j2,j3,n, ig0 );
          // printF("Corner Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);
          for( int k=0; k<=extrapOrder; k++ )
          {
            getGlobalIndex( j1+is1*k,j2+is2*k,j3,n, ig);
            ierr = MatSetValue(A,ig0,ig,extraplapCoeff[k],INSERT_VALUES);CHKERRQ(ierr);  
          }            
        }
      }
    }
  }

  ierr = MatAssemblyBegin(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  ierr = MatAssemblyEnd(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);



  // ----- MATRIX B = I -----

  ierr = MatCreate(PETSC_COMM_WORLD,&B);CHKERRQ(ierr);
  ierr = MatSetSizes(B,PETSC_DECIDE,PETSC_DECIDE,N,N);CHKERRQ(ierr);
  ierr = MatSetFromOptions(B);CHKERRQ(ierr);
  ierr = MatSetUp(B);CHKERRQ(ierr);

  ierr = MatGetOwnershipRange(B,&Istart,&Iend);CHKERRQ(ierr);
  if( !useNew )
  {
    for( int II=Istart; II<Iend; II++) 
    {
      int i = II/n; 
      int j = II-i*n;
      // if (i>0) { ierr = MatSetValue(B,II,II-n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
      // if (i<m-1) { ierr = MatSetValue(B,II,II+n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
      // if (j>0) { ierr = MatSetValue(B,II,II-1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
      // if (j<n-1) { ierr = MatSetValue(B,II,II+1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
      ierr = MatSetValue(B,II,II,1.0,INSERT_VALUES);CHKERRQ(ierr);
    }
  }
  else
  {
    // --- B(i,j) =1 : interior points ----
    getIndex(gid,I1,I2,I3,extra,extra,0);

    FOR_3D(i1,i2,i3,I1,I2,I3) 
    {
      getGlobalIndex( i1,i2,i3,n, ig0 );
      // printF("B ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);
      ierr = MatSetValue(B,ig0,ig0, 1.,INSERT_VALUES);CHKERRQ(ierr);      
    }
    if( true )
    {      
      // --- fill in boundary points (constraints) ----

      // FILL in a small value instead of zero for eigOption=0, since SLEPc wants B to be invertible

      const real smallValue = eigOption==0 ? tol/( SQR(dx[0]) ) : 0.; // 1.e-8; 

      ForBoundary(side,axis)
      {
        getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
        FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
        {
          getGlobalIndex( i1,i2,i3,n, ig0 );
          // printF("Boundary B: ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);
          ierr = MatSetValue(B,ig0,ig0, smallValue,INSERT_VALUES);CHKERRQ(ierr);  
        }          
      } 

      // --- fill in ghost points (constraints) ----
      ForBoundary(side,axis)
      {
        is1=is2=is3=0;
        isv[axis]=1-2*side;   // +1 on left and -1 on right 
        getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
        FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
        {
          for( int ghost=1; ghost<=numGhost; ghost++ )
          {
            int j1 = i1 -is1*ghost, j2 = i2 -is2*ghost,  j3 = i3;  // ghost point
            getGlobalIndex( j1,j2,j3,n, ig0 );
            // printF("B Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);
            ierr = MatSetValue(B,ig0,ig0, smallValue,INSERT_VALUES);CHKERRQ(ierr);             
          }
        }          
      }  

      // --- fill corners ----
      for( int side2=0; side2<=1; side2++ ) 
      {
        for( int side1=0; side1<=1; side1++ ) 
        {
          is1=1-2*side1; is2=1-2*side2; is3=0;
          i1 = gid(side1,0); i2=gid(side2,1); i3=0; // corner point 
          for( int ghost2=1; ghost2<=numGhost; ghost2++ )
          {
            for( int ghost1=1; ghost1<=numGhost; ghost1++ )
            {
              int j1 = i1 -is1*ghost1, j2 = i2 -is2*ghost2, j3 = i3;  // ghost point
              getGlobalIndex( j1,j2,j3,n, ig0 );
              // printF("B Corner Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);

              ierr = MatSetValue(B,ig0,ig0, smallValue,INSERT_VALUES);CHKERRQ(ierr);                  
            }
          }
        }
      }

    }   
  }

  ierr = MatAssemblyBegin(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  ierr = MatAssemblyEnd(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);

  return 0;
}


















// ==================================================================================
// Fill in the PETSc matrices A and B 
//          Incompressible elasticity 
//
//  Solve for the stream-function
//
//      Delta^2( u ) = - lambda* Delta(u)
//      BC: u=0, u.n = 0 
// ==================================================================================
int
fillMatrixIncompressibleElasticity( const int numberOfComponents, int orderOfAccuracy, MappedGrid & mg, Mat & A, Mat & B, 
                                    int numGhost, bool useNew, Real tol, int eigOption, IntegerArray & bc, int saveMatlab )
{

  int printEntries=0; 


  const Real rho=1., mu=1.; // ** FIX ME **




  PetscBool flag;
  int Istart,Iend,ierr;

  int includePressure=0;
  // if( numberOfComponents==2 || min(abs(bc-traction))==0 )
  if( numberOfComponents==2 ) 
  {
    includePressure=1;  // traction BCs need the pressure
  }

  printF("fillMatrixIncompressibleElasticity: numberOfComponents=%d, numberOfComponents=%d, numGhost=%d includePressure=%d\n",
        numberOfComponents,numberOfComponents,numGhost,includePressure); 

  const int numberOfDimensions = mg.numberOfDimensions();

  const bool isRectangular = mg.isRectangular();
  real dx[3]={1.,1.,1.};
  if( isRectangular )
    mg.getDeltaX(dx);

  assert( isRectangular );

  const IntegerArray & gid = mg.gridIndexRange();

  // No boundary points: 
  // int n = gid(1,0)-gid(0,0)+1 - 2;
  // int m = gid(1,1)-gid(0,1)+1 - 2;

  const int nd1a = gid(1,0)-gid(0,0)+1 + 2*numGhost;
  const int nd2a = gid(1,1)-gid(0,1)+1 + 2*numGhost;

  const int n1a = gid(0,0)-numGhost;
  const int n2a = gid(0,1)-numGhost;

  const int n1b = gid(1,0)+numGhost;
  const int n2b = gid(1,1)+numGhost;

  const int N = nd1a*nd2a*numberOfComponents; // total number of grid points

  // int orderOfAccuracy=2;
  const int extrapOrder = orderOfAccuracy+1;  // what should this be?

  const Real extraplapCoeff3[] = {1.,-3.,3.,-1.};
  const Real extraplapCoeff4[] = {1.,-4.,6.,-4.,1.};
  const Real extraplapCoeff5[] = {1.,-5.,10.,-10.,5.,-1.};
  const Real extraplapCoeff6[] = {1.,-6.,15.,-20.,15.,-6.,1.};
  const Real extraplapCoeff7[] = {1.,-7.,21.,-35.,35.,-21.,7.,-1.};
  const Real extraplapCoeff8[] = {1.,-8.,28.,-56.,70.,-56.,28.,-8.,1.};
  const Real extraplapCoeff9[] = {1.,-9.,36.,-84.,126.,-126.,84.,-36.,9.,-1.};
  const Real *extraplapCoeff;
  if( extrapOrder==3 )
    extraplapCoeff = extraplapCoeff3;
  else if( extrapOrder==4 )
    extraplapCoeff = extraplapCoeff4;
  else if( extrapOrder==5 )
    extraplapCoeff = extraplapCoeff5;
  else if( extrapOrder==6 )
    extraplapCoeff = extraplapCoeff6;
  else if( extrapOrder==7 )
    extraplapCoeff = extraplapCoeff7;    
  else if( extrapOrder==8 )
    extraplapCoeff = extraplapCoeff8;     
  else if( extrapOrder==9 )
    extraplapCoeff = extraplapCoeff9;               
  else
   {
    printF("fillMatrixIncompressibleElasticity:: unexpected extrapOrder=%d\n",extrapOrder);
    OV_ABORT("ERROR");
   }

  int i1,i2,i3;

  // int N = n*m;
  // int N = nd1a*nd2a*numberOfComponents;

  // ----- MATRIX A -----

  Real dx2i = 1./(dx[0]*dx[0]);
  Real dy2i = 1./(dx[1]*dx[1]);
  Real diag = 2.*dx2i + 2.*dy2i; 

  int hw = orderOfAccuracy/2; // stencil half with
  int hw2 = hw+1; // half-width stencil for bi-Harmonic 
  Range S(-hw,hw); // stencil
  Range S2(-hw2,hw2); 

  RealArray lapCoeff(S2,S2);
  lapCoeff=0.;

  RealArray biCoeff(S2,S2), xxxCoeff(S2), yyyCoeff(S2), xxxxCoeff(S2), yyyyCoeff(S2);
  biCoeff=0.; xxxCoeff=0.; yyyCoeff=0.; xxxxCoeff=0.; yyyyCoeff=0.;

  RealArray xCoeff(S2), yCoeff(S2), xxCoeff(S2), yyCoeff(S2), xxyyCoeff(S2,S2), xxyCoeff(S2,S2), xyyCoeff(S2,S2); 
  xCoeff=0.; yCoeff=0.; xxCoeff=0.; yyCoeff=0.; xxyyCoeff=0.; xxyCoeff=0.; xyyCoeff=0.;

  // identity
  RealArray iCoeff(S2,S2);
  iCoeff=0.; 
  iCoeff(0,0)=1.;

  if( orderOfAccuracy==2 )
  {



    if( numGhost>1 )
    {
      hw = hw2; // **** NOTE ***

      // **** USE ORDER=4 operators where appropriate ****
      // --- Dx and Dy coefficients ---
      xCoeff(-2) =  1./(12.*dx[0]);
      xCoeff(-1) = -8./(12.*dx[0]);
      xCoeff( 0) =  0./(12.*dx[0]);
      xCoeff(+1) =  8./(12.*dx[0]);
      xCoeff(+2) = -1./(12.*dx[0]);

      yCoeff(-2) =  1./(12.*dx[1]);
      yCoeff(-1) = -8./(12.*dx[1]);
      yCoeff( 0) =  0./(12.*dx[1]);
      yCoeff(+1) =  8./(12.*dx[1]);
      yCoeff(+2) = -1./(12.*dx[1]);    


      xxCoeff(-2) =  -1./(12.*SQR(dx[0]));
      xxCoeff(-1) =  16./(12.*SQR(dx[0]));
      xxCoeff( 0) = -30./(12.*SQR(dx[0]));
      xxCoeff(+1) =  16./(12.*SQR(dx[0]));
      xxCoeff(+2) =  -1./(12.*SQR(dx[0]));   

      yyCoeff(-2) =  -1./(12.*SQR(dx[1]));
      yyCoeff(-1) =  16./(12.*SQR(dx[1]));
      yyCoeff( 0) = -30./(12.*SQR(dx[1]));
      yyCoeff(+1) =  16./(12.*SQR(dx[1]));
      yyCoeff(+2) =  -1./(12.*SQR(dx[1]));  

      // -- -Laplacian : ORDER=4 --
      lapCoeff(0,0)  =  30./(12.*SQR(dx[0])) + 30./(12.*SQR(dx[1]));

      lapCoeff(-2,0) =   1./(12.*SQR(dx[0]));
      lapCoeff(-1,0) = -16./(12.*SQR(dx[0]));
      lapCoeff(+1,0) = -16./(12.*SQR(dx[0]));
      lapCoeff(+2,0) =   1./(12.*SQR(dx[0]));

      lapCoeff(0,-2) =   1./(12.*SQR(dx[1]));
      lapCoeff(0,-1) = -16./(12.*SQR(dx[1]));
      lapCoeff(0,+1) = -16./(12.*SQR(dx[1]));   
      lapCoeff(0,+2) =   1./(12.*SQR(dx[1])); 
    }
    else
    {
      // --- Dx and Dy coefficients ---
      xCoeff(-1) = -1./(2.*dx[0]);
      xCoeff(+1) =  1./(2.*dx[0]);

      yCoeff(-1) = -1./(2.*dx[1]);
      yCoeff(+1) =  1./(2.*dx[1]);

      xxCoeff(-1) =  1./(SQR(dx[0]));
      xxCoeff( 0) = -2./(SQR(dx[0]));
      xxCoeff(+1) =  1./(SQR(dx[0]));

      yyCoeff(-1) =  1./(SQR(dx[1]));
      yyCoeff( 0) = -2./(SQR(dx[1]));
      yyCoeff(+1) =  1./(SQR(dx[1]));        

      // ----  -Delta : order=2 ----
      lapCoeff(0,0)  =  2./SQR(dx[0]) + 2./SQR(dx[1]);

      lapCoeff(-1,0) = -1./SQR(dx[0]);
      lapCoeff(+1,0) = -1./SQR(dx[0]);

      lapCoeff(0,-1) = -1./SQR(dx[1]);
      lapCoeff(0,+1) = -1./SQR(dx[1]); 
    } 

    xxxCoeff(-2) = -1./(pow(dx[0],3));
    xxxCoeff(-1) =  2./(pow(dx[0],3));
    xxxCoeff( 0) =  0./(pow(dx[0],3));
    xxxCoeff(+1) = -2./(pow(dx[0],3));
    xxxCoeff(+2) =  1./(pow(dx[0],3));

    yyyCoeff(-2) = -1./(pow(dx[1],3));
    yyyCoeff(-1) =  2./(pow(dx[1],3));
    yyyCoeff( 0) =  0./(pow(dx[1],3));
    yyyCoeff(+1) = -2./(pow(dx[1],3));
    yyyCoeff(+2) =  1./(pow(dx[1],3));

       

    // ---- Bi-Harmonic coefficients ------
    //   Dxxxx + 2*Dxxyy + Dyyyy
    //  Dxxxx = [ 1 -4 6 -4 1 ]/( dx^4 )
    //          [ 1 -2  1]
    //  Dxxyy = [-2  4 -2]/ (dx^2 dy^2)
    //          [ 1 -2  1]
    const Real dx2 = pow(dx[0],2.);
    const Real dy2 = pow(dx[1],2.);
    const Real dx4 = pow(dx[0],4.);
    const Real dy4 = pow(dx[1],4.);
    biCoeff(0,0)  =  6./dx4 + 6./dy4 + 2.*4./(dx2*dy2); 

    biCoeff(-2,0) =  1./(dx4);
    biCoeff(-1,0) = -4./(dx4)  -2.*2./(dx2*dy2);
    biCoeff(+1,0) = -4./(dx4)  -2.*2./(dx2*dy2);
    biCoeff(+2,0) =  1./(dx4);

    biCoeff(0,-2) =  1./(dy4);
    biCoeff(0,-1) = -4./(dy4)  -2.*2./(dx2*dy2);
    biCoeff(0,+1) = -4./(dy4)  -2.*2./(dx2*dy2);   
    biCoeff(0,+2) =  1./(dy4);   

    biCoeff(-1,-1) = 2.*1./(dx2*dy2);
    biCoeff(+1,-1) = 2.*1./(dx2*dy2);        
    biCoeff(-1,+1) = 2.*1./(dx2*dy2);
    biCoeff(+1,+1) = 2.*1./(dx2*dy2);  

    for( int iw2=-hw; iw2<=hw; iw2++ )
    {
      for( int iw1=-hw; iw1<=hw; iw1++ )
      {
        xxyCoeff(iw1,iw2) = xxCoeff(iw1)* yCoeff(iw2); 
        xyyCoeff(iw1,iw2) =  xCoeff(iw1)*yyCoeff(iw2); 
      }
    }  

  }
  else if( orderOfAccuracy==4 )
  {
    // ---- order=4 ----

    // --- Dx and Dy coefficients ---
    xCoeff(-2) =  1./(12.*dx[0]);
    xCoeff(-1) = -8./(12.*dx[0]);
    xCoeff( 0) =  0./(12.*dx[0]);
    xCoeff(+1) =  8./(12.*dx[0]);
    xCoeff(+2) = -1./(12.*dx[0]);

    yCoeff(-2) =  1./(12.*dx[1]);
    yCoeff(-1) = -8./(12.*dx[1]);
    yCoeff( 0) =  0./(12.*dx[1]);
    yCoeff(+1) =  8./(12.*dx[1]);
    yCoeff(+2) = -1./(12.*dx[1]);    


    xxCoeff(-2) =  -1./(12.*SQR(dx[0]));
    xxCoeff(-1) =  16./(12.*SQR(dx[0]));
    xxCoeff( 0) = -30./(12.*SQR(dx[0]));
    xxCoeff(+1) =  16./(12.*SQR(dx[0]));
    xxCoeff(+2) =  -1./(12.*SQR(dx[0]));   

    yyCoeff(-2) =  -1./(12.*SQR(dx[1]));
    yyCoeff(-1) =  16./(12.*SQR(dx[1]));
    yyCoeff( 0) = -30./(12.*SQR(dx[1]));
    yyCoeff(+1) =  16./(12.*SQR(dx[1]));
    yyCoeff(+2) =  -1./(12.*SQR(dx[1]));  

    for( int iw2=-hw; iw2<=hw; iw2++ )
    {
      for( int iw1=-hw; iw1<=hw; iw1++ )
      {
        xxyyCoeff(iw1,iw2) = xxCoeff(iw1)*yyCoeff(iw2); 
      }
    }

    xxxxCoeff(-3) =  -1./(6.*pow(dx[0],4.));
    xxxxCoeff(-2) =  12./(6.*pow(dx[0],4.));
    xxxxCoeff(-1) = -39./(6.*pow(dx[0],4.));
    xxxxCoeff( 0) =  56./(6.*pow(dx[0],4.));
    xxxxCoeff(+1) = -39./(6.*pow(dx[0],4.));
    xxxxCoeff(+2) =  12./(6.*pow(dx[0],4.));              
    xxxxCoeff(+3) =  -1./(6.*pow(dx[0],4.));  

    yyyyCoeff(-3) =  -1./(6.*pow(dx[1],4.));
    yyyyCoeff(-2) =  12./(6.*pow(dx[1],4.));
    yyyyCoeff(-1) = -39./(6.*pow(dx[1],4.));
    yyyyCoeff( 0) =  56./(6.*pow(dx[1],4.));
    yyyyCoeff(+1) = -39./(6.*pow(dx[1],4.));
    yyyyCoeff(+2) =  12./(6.*pow(dx[1],4.));              
    yyyyCoeff(+3) =  -1./(6.*pow(dx[1],4.));                  


    // -- -Laplacian --
    lapCoeff(0,0)  =  30./(12.*SQR(dx[0])) + 30./(12.*SQR(dx[1]));

    lapCoeff(-2,0) =   1./(12.*SQR(dx[0]));
    lapCoeff(-1,0) = -16./(12.*SQR(dx[0]));
    lapCoeff(+1,0) = -16./(12.*SQR(dx[0]));
    lapCoeff(+2,0) =   1./(12.*SQR(dx[0]));

    lapCoeff(0,-2) =   1./(12.*SQR(dx[1]));
    lapCoeff(0,-1) = -16./(12.*SQR(dx[1]));
    lapCoeff(0,+1) = -16./(12.*SQR(dx[1]));   
    lapCoeff(0,+2) =   1./(12.*SQR(dx[1])); 

    // Delta^2 = Dxxxx + Dyyyy + 2*Dxxyy
    for( int iw=-hw2; iw<=hw2; iw++ ) 
    {
      biCoeff(iw,0) += xxxxCoeff(iw);
      biCoeff(0,iw) += yyyyCoeff(iw);
    }

    for( int iw2=-hw; iw2<=hw; iw2++ )
    {
      for( int iw1=-hw; iw1<=hw; iw1++ )
      {
        biCoeff(iw1,iw2) += 2.*xxyyCoeff(iw1,iw2);
      }
    }


  }
  else if( orderOfAccuracy==6 )
  {
    // ----  -Delta : order=6 ----
    lapCoeff(0,0)  =  490./(180.*SQR(dx[0])) + 490./(180.*SQR(dx[1]));

    lapCoeff(-3,0) =   -2./(180.*SQR(dx[0]));
    lapCoeff(-2,0) =   27./(180.*SQR(dx[0]));
    lapCoeff(-1,0) = -270./(180.*SQR(dx[0]));
    lapCoeff(+1,0) = -270./(180.*SQR(dx[0]));
    lapCoeff(+2,0) =   27./(180.*SQR(dx[0]));
    lapCoeff(+3,0) =   -2./(180.*SQR(dx[0]));

    lapCoeff(0,-3) =   -2./(180.*SQR(dx[1]));
    lapCoeff(0,-2) =   27./(180.*SQR(dx[1]));
    lapCoeff(0,-1) = -270./(180.*SQR(dx[1]));
    lapCoeff(0,+1) = -270./(180.*SQR(dx[1]));   
    lapCoeff(0,+2) =   27./(180.*SQR(dx[1]));   
    lapCoeff(0,+3) =   -2./(180.*SQR(dx[1]));   

    OV_ABORT("biH - finish me");

  }  
  else if( orderOfAccuracy==8 )
  {
    // ----  -Delta : order=8 ----
    lapCoeff(0,0)  =  14350./(5040.*SQR(dx[0])) + 14350./(5040.*SQR(dx[1]));

    lapCoeff(-4,0) =     9./(5040.*SQR(dx[0]));
    lapCoeff(-3,0) =  -128./(5040.*SQR(dx[0]));
    lapCoeff(-2,0) =  1008./(5040.*SQR(dx[0]));
    lapCoeff(-1,0) = -8064./(5040.*SQR(dx[0]));
    lapCoeff(+1,0) = -8064./(5040.*SQR(dx[0]));
    lapCoeff(+2,0) =  1008./(5040.*SQR(dx[0]));
    lapCoeff(+3,0) =  -128./(5040.*SQR(dx[0]));
    lapCoeff(+4,0) =     9./(5040.*SQR(dx[0]));

    lapCoeff(0,-4) =     9./(5040.*SQR(dx[1]));
    lapCoeff(0,-3) =  -128./(5040.*SQR(dx[1]));
    lapCoeff(0,-2) =  1008./(5040.*SQR(dx[1]));
    lapCoeff(0,-1) = -8064./(5040.*SQR(dx[1]));
    lapCoeff(0,+1) = -8064./(5040.*SQR(dx[1]));   
    lapCoeff(0,+2) =  1008./(5040.*SQR(dx[1]));   
    lapCoeff(0,+3) =  -128./(5040.*SQR(dx[1]));   
    lapCoeff(0,+4) =     9./(5040.*SQR(dx[1])); 

    OV_ABORT("biH - finish me");
  }    
  else
  {
    OV_ABORT("finish me - orderOfAccuracy");
  }

  ierr = MatCreate(PETSC_COMM_WORLD,&A);CHKERRQ(ierr);
  ierr = MatSetSizes(A,PETSC_DECIDE,PETSC_DECIDE,N,N);CHKERRQ(ierr);
  ierr = MatSetFromOptions(A);CHKERRQ(ierr);
  ierr = MatSetUp(A);CHKERRQ(ierr);

  ierr = MatGetOwnershipRange(A,&Istart,&Iend);CHKERRQ(ierr);

  Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
  Index Ipv[3], &Ip1=Ipv[0], &Ip2=Ipv[1], &Ip3=Ipv[2]; // bounds for pressure interior equation
  Index Ibv[3], &Ib1=Ibv[0], &Ib2=Ibv[1], &Ib3=Ibv[2];
  Index Igv[3], &Ig1=Igv[0], &Ig2=Igv[1], &Ig3=Igv[2];
  int isv[3], &is1=isv[0], &is2=isv[1], &is3=isv[2];

  // ---- get interior points ----
  // int extra=-1;
  // getIndex(gid,I1,I2,I3,extra,extra,0);
  int ig0,ig; 

  int n=0; // component number
  const int psim = 0;  // psi component in the matrix
  const int pm = 1;    // p component in the matrix 

  // ---- Fill equation for psi points ----
  //   bc = displacement : skip boundary for psi
  //      = traction     : include boundary
  getIndex(gid,I1,I2,I3);
  for( int axis=0; axis<numberOfDimensions; axis++ )
  {
    int ia = bc(0,axis)==displacement ? gid(0,axis)+1 : gid(0,axis); 
    int ib = bc(1,axis)==displacement ? gid(1,axis)-1 : gid(1,axis); 
    Iv[axis] = Range(ia,ib); 
  }  
  printF("Psi interior equation bounds: [%d,%d][%d,%d]\n",
               I1.getBase(),I1.getBound(),
               I2.getBase(),I2.getBound() );

  FOR_3D(i1,i2,i3,I1,I2,I3) 
  {
     getGlobalIndex( i1,i2,i3,psim, ig0 );

     // printF("Interior: ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);

     // --- FILL BI-HARMONIC ----
     // --- loop over stencil ---
     for( int iw2=-hw2; iw2<=hw2; iw2++ )
     {
       for( int iw1=-hw2; iw1<=hw2; iw1++ )
       {
         Real coeff = biCoeff(iw1,iw2); 
         // coeff = iCoeff(iw1,iw2); // *************************** TEMP
         if( coeff != 0. )
         {
            getGlobalIndex( i1+iw1,i2+iw2,i3,psim, ig );
            ierr = MatSetValue(A,ig0,ig, coeff,INSERT_VALUES);CHKERRQ(ierr); 

            printMatrixEntry( ig0,ig,coeff,interiorPsi);            
          }
       }
     }

  } 
  if( includePressure )
  {
    // --- Set bounds on pressure interior equation ---
    //  bc=displacement : include boundary
    //    =traction     : exclude boundary
    getIndex(gid,Ip1,Ip2,Ip3);
    for( int axis=0; axis<numberOfDimensions; axis++ )
    {
      int ia = bc(0,axis)==traction ? gid(0,axis)+1 : gid(0,axis); 
      int ib = bc(1,axis)==traction ? gid(1,axis)-1 : gid(1,axis); 

      Ipv[axis] = Range(ia,ib); 
    }
    printF("Pressure equation bounds for Lap: [%d,%d][%d,%d]\n",
               Ip1.getBase(),Ip1.getBound(),
               Ip2.getBase(),Ip2.getBound() );

    FOR_3D(i1,i2,i3,Ip1,Ip2,Ip3) 
    {
      getGlobalIndex( i1,i2,i3,pm, ig0 );
      // printF("Interior: ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);
      // --- FILL Delta for p ----
      // --- loop over stencil ---
      for( int iw2=-hw; iw2<=hw; iw2++ )
      {
        for( int iw1=-hw; iw1<=hw; iw1++ )
        {
          if( lapCoeff(iw1,iw2) != 0. )
          {
             getGlobalIndex( i1+iw1,i2+iw2,i3,pm, ig );
             ierr = MatSetValue(A,ig0,ig, -lapCoeff(iw1,iw2),INSERT_VALUES);CHKERRQ(ierr);   // flip sign *fix me*

             printMatrixEntry( ig0,ig,-lapCoeff(iw1,iw2),interiorP);                 
           }
        }
      }
    } 
  }
    
  // --- fill in boundary points (constraints) ----
  ForBoundary(side,axis)
  {
    getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
    if( bc(side,axis)==displacement )
    {
      FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
      {
        getGlobalIndex( i1,i2,i3,psim, ig0 );
        // printF("Boundary: ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);

        // --- Dirichlet BC for psi :
        ierr = MatSetValue(A,ig0,ig0, 1.,INSERT_VALUES);CHKERRQ(ierr);

        printMatrixEntry( ig0,ig,1.,psiDisplacementBoundaryDirichlet );  

      } 
    }

    if( includePressure && bc(side,axis)==traction )  
    {
      // Traction BC for p:
      //    p = 2*mu*u.x
      //    p = 2*mu*v.y 
      FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
      {
        getGlobalIndex( i1,i2,i3,pm, ig0 );
        // printF("Boundary: ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);

        // --- Dirichlet BC for p :
        ierr = MatSetValue(A,ig0,ig0, 1.,INSERT_VALUES);CHKERRQ(ierr); 

        Real coeff=0.;
        for( int iw=-hw; iw<=hw; iw++ )
        {
           if( axis==0 )
           {
             getGlobalIndex( i1+iw,i2,i3,psim, ig ); // centre stencil on the boundary (i1,i2,i3)
             coeff = 2.*mu*xCoeff(iw);
           }
           else
           {
             getGlobalIndex( i1,i2+iw,i3,psim, ig );   // centre stencil on the boundary 
             coeff = 2.*mu*yCoeff(iw);
           }
           if( coeff !=0. )
           {
             ierr = MatSetValue(A,ig0,ig, coeff,INSERT_VALUES);CHKERRQ(ierr);  
           }

        }        

      }       
    }           
  } 

  // --- fill in ghost points (constraints) ----

  ForBoundary(side,axis)
  {
    is1=is2=is3=0; isv[axis]=1-2*side;   // +1 on left and -1 on right 
    getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
    FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
    {

      int ghost = 1;
      int j1 = i1 -is1*ghost, j2 = i2 -is2*ghost,  j3 = i3;  // ghost point

      getGlobalIndex( j1,j2,j3,psim, ig0 );   // ghost point - put equation here 

      int startGhost=2; // start extrapolation here
      if( bc(side,axis)==displacement )
      {

        // --- Neumann BC on first ghost line for psi ---

        Real coeff=0.;
        for( int iw=-hw; iw<=hw; iw++ )
        {
           if( axis==0 )
           {
             getGlobalIndex( i1+iw,i2,i3,psim, ig ); // centre stencil on the boundary (i1,i2,i3)
             coeff = xCoeff(iw);
           }
           else
           {
             getGlobalIndex( i1,i2+iw,i3,psim, ig );   // centre stencil on the boundary 
             coeff = yCoeff(iw);
           }
           if( coeff !=0. )
           {
             ierr = MatSetValue(A,ig0,ig, coeff,INSERT_VALUES);CHKERRQ(ierr);

             printMatrixEntry( ig0,ig,coeff,psiDisplacementGhost1Neumann);  
           }

        }
      }
      else if( bc(side,axis)==traction )
      {
        // Traction BC: 
        //    psi.xx - psi.yy = 0 (except at traction-traction corners)
        bool tractionTractionCorner = false;
        if( (axis==0 && i2==gid(0,1) && bc(0,1)==traction) || 
            (axis==0 && i2==gid(1,1) && bc(1,1)==traction) ||
            (axis==1 && i1==gid(0,0) && bc(0,0)==traction) || 
            (axis==1 && i1==gid(1,0) && bc(1,0)==traction)
          )
        {
          tractionTractionCorner=true;
          printF("tractionTraction corner found at (side,axis)=(%d,%d)\n",side,axis);
          OV_ABORT("finish me");
        }

        bool tractionDisplacementCorner = false;
        if( (axis==0 && i2==gid(0,1) && bc(0,1)==displacement) || 
            (axis==0 && i2==gid(1,1) && bc(1,1)==displacement) ||
            (axis==1 && i1==gid(0,0) && bc(0,0)==displacement) || 
            (axis==1 && i1==gid(1,0) && bc(1,0)==displacement)
          )
        {
          tractionDisplacementCorner=true;
          printF("tractionDisplacement corner found at (side,axis)=(%d,%d)\n",side,axis);
        }


        startGhost=3; 

        if( !tractionDisplacementCorner )
        {
          // --- loop over stencil ---
          for( int iw2=-hw; iw2<=hw; iw2++ )
          {
            for( int iw1=-hw; iw1<=hw; iw1++ )
            {
              Real coeff = xxCoeff(iw1) - yyCoeff(iw2); 
              // wrong : center at ghost coeff = iCoeff(iw1,iw2); // ******************** TEST  TEMP
              // // *** TEST: 
              // if( axis==0 )
              //   coeff = xxCoeff(iw1);
              // else
              //   coeff = yyCoeff(iw2);
              if( coeff != 0. )
              {
                 getGlobalIndex( i1+iw1,i2+iw2,i3,psim, ig );
                 ierr = MatSetValue(A,ig0,ig, coeff,INSERT_VALUES);CHKERRQ(ierr);   // flip sign *fix me*
                 printMatrixEntry( ig0,ig,coeff,psiTractionGhost1); 
               }
            }
          }  
        }
        else
        {
          //      | bc=traction
          //      |
          //      |
          //   G--C----  displacement
          //      | 
          // 
          // Just set a Dirichlet condition for psi for the ghost point G on the extended
          // displacement BC
          ierr = MatSetValue(A,ig0,ig0, 1.,INSERT_VALUES);CHKERRQ(ierr); 
          printMatrixEntry( ig0,ig0,1.,tractionDisplacementExtendedBoundary1PsiDirichlet);   
        }      

 

        // Traction CBC for ghost=2: 
        // Traction CBC for pressure is u_2 or u_1 equation
        //  mu*( psi.xxx + psi.xyy) + p.y + lambda*psi.x = 0 : x=0,1
        //  mu*( psi.xxy + psi.yyy) - p.x + lambda*psi.y = 0 : y=0,1   
        // OR      
        //  mu*( psi.xxx + 3*psi.xyy) + lambda*psi.x = 0 : x=0,1
        //  mu*( psi.xxy + 3*psi.yyy) + lambda*psi.y = 0 : y=0,1        

        int ghost = 2;
        int j1 = i1 -is1*ghost, j2 = i2 -is2*ghost,  j3 = i3;  // ghost point

        getGlobalIndex( j1,j2,j3,psim, ig0 );   // ghost point 2 - put equation here  
        if( !tractionDisplacementCorner )
        {               
          // --- loop over stencil ---
          Real coeff=0., pCoeff=0.; 
          for( int iw2=-hw2; iw2<=hw2; iw2++ )
          {
            for( int iw1=-hw2; iw1<=hw2; iw1++ )
            {
              if( axis==0 )
              {
                coeff = mu*( xxxCoeff(iw1) + 3.*xyyCoeff(iw1,iw2) );  

                // wrong : center at ghost coeff = iCoeff(iw1,iw2); // ******************** TEST  TEMP
               
                // coeff = mu*( xxxCoeff(iw1) + 0.*xyyCoeff(iw1,iw2) );   // TEST ***********
                //pCoeff = yCoeff(iw2); 
              }
              else
              {
                coeff = mu*( 3.*xxyCoeff(iw1,iw2) + yyyCoeff(iw2) ); 
                //pCoeff = -xCoeff(iw1); 
              }
              if( coeff != 0. )
              {
                 getGlobalIndex( i1+iw1,i2+iw2,i3,psim, ig );
                 ierr = MatSetValue(A,ig0,ig, coeff,INSERT_VALUES);CHKERRQ(ierr); 

                 printMatrixEntry( ig0,ig,coeff,psiTractionGhost2psixxx);                  
  
                 // getGlobalIndex( i1+iw1,i2+iw2,i3,pm, ig );
                 // ierr = MatSetValue(A,ig0,ig, pCoeff,INSERT_VALUES);CHKERRQ(ierr); 
               }
            }
          } 
        }
        else
        {
          //        | bc=traction
          //        |
          //        |
          // G2--G--C----  displacement
          //        | 
          // 
          // Just set a Dirichlet condition for psi for the ghost point G2 on the extended
          // displacement BC
          ierr = MatSetValue(A,ig0,ig0, 1.,INSERT_VALUES);CHKERRQ(ierr);  
          printMatrixEntry( ig0,ig0,1.,tractionDisplacementExtendedBoundary2PsiDirichlet);         
        }

      }
 

      // -- extrapolate other ghost 
      for( int ghost=startGhost; ghost<=numGhost; ghost++ )
      {
        int j1 = i1 -is1*ghost, j2 = i2 -is2*ghost,  j3 = i3;  // ghost point
        getGlobalIndex( j1,j2,j3,psim, ig0 );
        // printF("Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);
        for( int k=0; k<=extrapOrder; k++ )
        {
          getGlobalIndex( j1+is1*k,j2+is2*k,j3,psim, ig);
          ierr = MatSetValue(A,ig0,ig,extraplapCoeff[k],INSERT_VALUES);CHKERRQ(ierr); 
          printMatrixEntry( ig0,ig,extraplapCoeff[k],extrapGhostPsi);    
        }
      }



    } // end FOR3D


    if( includePressure ) 
    {
      RealArray psiCoeff(S2,S2);

      FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
      {
        int ghost = 1;
        int j1 = i1 -is1*ghost, j2 = i2 -is2*ghost,  j3 = i3;  // ghost point

        getGlobalIndex( j1,j2,j3,pm, ig0 );   // ghost point - put equation here 

        int startGhost=1; // start extrap at this ghost 
        if( bc(side,axis)==displacement )
        {
          // --- Displacement BC:  Neumann BC on first ghost line for p ---
          //   p.x = mu*u.xx =  mu*psi.xxy 
          //   p.y = mu*v.yy = -mu*psi.xyy
          startGhost=2; 
          Real coeff=0.;
          for( int iw=-hw; iw<=hw; iw++ )
          {
             if( axis==0 )
             {
               getGlobalIndex( i1+iw,i2,i3,pm, ig ); // centre stencil on the boundary (i1,i2,i3)
               coeff  = xCoeff(iw);
             }
             else
             {
               getGlobalIndex( i1,i2+iw,i3,pm, ig );   // centre stencil on the boundary 
               coeff = yCoeff(iw);
             }
             if( coeff !=0. )
             {
               ierr = MatSetValue(A,ig0,ig, coeff,INSERT_VALUES);CHKERRQ(ierr); 

               printMatrixEntry( ig0,ig,coeff,displacementGhost1p); 
             }
          }

          // At a displacement-displacement corner we just set
          //   p.x = 0 or p.y = 0
          bool displacementDisplacementCorner = false;
          if( (axis==0 && i2==gid(0,1) && bc(0,1)==displacement) || 
              (axis==0 && i2==gid(1,1) && bc(1,1)==displacement) ||
              (axis==1 && i1==gid(0,0) && bc(0,0)==displacement) || 
              (axis==1 && i1==gid(1,0) && bc(1,0)==displacement)
            )
          {
            displacementDisplacementCorner=true;
            printF("displacementDisplacement corner found at (side,axis)=(%d,%d)\n",side,axis);
          }
          if( !displacementDisplacementCorner )
          {
            if( axis==0 )
              psiCoeff =  mu*xxyCoeff;
            else
              psiCoeff = -mu*xyyCoeff;

            // --- loop over stencil ---
            for( int iw2=-hw; iw2<=hw; iw2++ )
            {
              for( int iw1=-hw; iw1<=hw; iw1++ )
              {
                if( psiCoeff(iw1,iw2) != 0. )
                {
                   getGlobalIndex( i1+iw1,i2+iw2,i3,psim, ig );
                   ierr = MatSetValue(A,ig0,ig, psiCoeff(iw1,iw2),INSERT_VALUES);CHKERRQ(ierr);

                 }
              }
            }
          }

        }
        else if( bc(side,axis)==traction )
        {
          // Traction CBC for ghost=2: 
          // Traction CBC for pressure is u_2 or u_1 equation
          //  mu*( psi.xxx + psi.xyy) + p.y + lambda*psi.x = 0 : x=0,1
          //  mu*( psi.xxy + psi.yyy) - p.x + lambda*psi.y = 0 : y=0,1 

          // -- done above ---

        }

        // -- extrapolate other ghost for p ---
        for( int ghost=startGhost; ghost<=numGhost; ghost++ )
        {
          int j1 = i1 -is1*ghost, j2 = i2 -is2*ghost,  j3 = i3;  // ghost point
          getGlobalIndex( j1,j2,j3,pm, ig0 );
          // printF("Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);
          for( int k=0; k<=extrapOrder; k++ )
          {
            getGlobalIndex( j1+is1*k,j2+is2*k,j3,pm, ig);
            ierr = MatSetValue(A,ig0,ig,extraplapCoeff[k],INSERT_VALUES);CHKERRQ(ierr); 

            printMatrixEntry( ig0,ig,extraplapCoeff[k],extrapGhostp);  
          }
        }

      }
    }

  }  // end ForBoundary

  // --- fill corners ----
  for( int side2=0; side2<=1; side2++ ) 
  {
    for( int side1=0; side1<=1; side1++ ) 
    {
      is1=1-2*side1; is2=1-2*side2; is3=0;
      i1 = gid(side1,0); i2=gid(side2,1); i3=0; // corner point 
      for( int ghost2=1; ghost2<=numGhost; ghost2++ )
      {
        for( int ghost1=1; ghost1<=numGhost; ghost1++ )
        {
          int j1 = i1 -is1*ghost1, j2 = i2 -is2*ghost2, j3 = i3;  // ghost point
          for( int n=0; n<numberOfComponents; n++ )
          {
            getGlobalIndex( j1,j2,j3,n, ig0 );
            // printF("Corner Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);
            for( int k=0; k<=extrapOrder; k++ )
            {
              getGlobalIndex( j1+is1*k,j2+is2*k,j3,n, ig);
              ierr = MatSetValue(A,ig0,ig,extraplapCoeff[k],INSERT_VALUES);CHKERRQ(ierr); 
              if( n==0 ) 
              {
                printMatrixEntry( ig0,ig,extraplapCoeff[k],extrapCornerGhostPsi);
              }
              else
              {
                printMatrixEntry( ig0,ig,extraplapCoeff[k],extrapCornerGhostp);
              }
            } 
          }           
        }
      }
    }
  }

  ierr = MatAssemblyBegin(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  ierr = MatAssemblyEnd(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);


  if( saveMatlab )
  {
    PetscViewer viewer;
    PetscObjectSetName((PetscObject)A, "A");

    // if( false )
    // {
    //   PetscViewerCreate(PETSC_COMM_WORLD, &viewer);
    //   // PetscViewerSetType(viewer, PETSCVIEWERASCII);
    //   PetscViewerSetType(viewer, PETSCVIEWERMATLAB);
    //   // PetscViewerPushFormat(viewer, PETSC_VIEWER_ASCII_MATLAB); 
    //   PetscViewerFileSetMode(viewer, FILE_MODE_WRITE);
    //   PetscViewerFileSetName(viewer, "eigMatA.m");
    // }

    // viewer = PETSC_VIEWER_STDOUT_(PETSC_COMM_WORLD);
    PetscViewerASCIIOpen(PETSC_COMM_WORLD,"eigMatA.m",&viewer);
    // PetscViewerFileSetName(viewer, "myMat.m");
    // // ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_READ,&viewer);CHKERRQ(ierr);
    PetscViewerPushFormat(viewer, PETSC_VIEWER_ASCII_MATLAB);    

    MatView(A,viewer);

    printF("Saved Matrix A to file=[eigMatA.m]\n");
    // PetscViewerPopFormat(viewer);
  }

//  OV_ABORT("stop here for now");

  // ----- MATRIX B = Delta -----

  ierr = MatCreate(PETSC_COMM_WORLD,&B);CHKERRQ(ierr);
  ierr = MatSetSizes(B,PETSC_DECIDE,PETSC_DECIDE,N,N);CHKERRQ(ierr);
  ierr = MatSetFromOptions(B);CHKERRQ(ierr);
  ierr = MatSetUp(B);CHKERRQ(ierr);

  ierr = MatGetOwnershipRange(B,&Istart,&Iend);CHKERRQ(ierr);

  // --- B(i,j) = -Delta : interior points ----
  // extra=-1; 
  // getIndex(gid,I1,I2,I3,extra,extra,0);
  printF("Matrix B: Psi interior equation bounds: [%d,%d][%d,%d]\n",
               I1.getBase(),I1.getBound(),
               I2.getBase(),I2.getBound() );  
  FOR_3(i1,i2,i3,I1,I2,I3) 
  {
    getGlobalIndex( i1,i2,i3,psim, ig0 );
    // printF("B ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);
    // --- loop over stencil ---
    for( int iw2=-hw; iw2<=hw; iw2++ )
    {
      for( int iw1=-hw; iw1<=hw; iw1++ )
      {
        if( lapCoeff(iw1,iw2) != 0. )
        {
           getGlobalIndex( i1+iw1,i2+iw2,i3,psim, ig );
           ierr = MatSetValue(B,ig0,ig, lapCoeff(iw1,iw2),INSERT_VALUES);CHKERRQ(ierr); 
         }
      }
    }        
  }

  // --- fill in boundary points (constraints) ----
  ForBoundary(side,axis)
  {
    is1=is2=is3=0; isv[axis]=1-2*side;   // +1 on left and -1 on right     
    if( bc(side,axis)==traction )
    {
      getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
      FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
      {
 
        // Traction CBC for ghost=2: 
        // Traction CBC for pressure is u_2 or u_1 equation
        //  mu*( psi.xxx + psi.xyy) + p.y + lambda*psi.x = 0 : x=0,1
        //  mu*( psi.xxy + psi.yyy) - p.x + lambda*psi.y = 0 : y=0,1 
        // OR      
        //  mu*( psi.xxx + 3*psi.xyy) + lambda*psi.x = 0 : x=0,1
        //  mu*( psi.xxy + 3*psi.yyy) + lambda*psi.y = 0 : y=0,1  

        bool tractionDisplacementCorner = false;
        if( (axis==0 && i2==gid(0,1) && bc(0,1)==displacement) || 
            (axis==0 && i2==gid(1,1) && bc(1,1)==displacement) ||
            (axis==1 && i1==gid(0,0) && bc(0,0)==displacement) || 
            (axis==1 && i1==gid(1,0) && bc(1,0)==displacement)
          )
        {
          tractionDisplacementCorner=true;
          printF("B: tractionDisplacement corner found at (side,axis)=(%d,%d)\n",side,axis);
        }                        
        if( !tractionDisplacementCorner )
        {
          int ghost = 2;
          int j1 = i1 -is1*ghost, j2 = i2 -is2*ghost,  j3 = i3;  // ghost point
          getGlobalIndex( j1,j2,j3,psim, ig0 );   // ghost point 2 - put equation here  

          // --- loop over stencil ---
          Real coeff=0.;
          for( int iw2=-hw; iw2<=hw; iw2++ )
          {
            for( int iw1=-hw; iw1<=hw; iw1++ )
            {
              if( axis==0 )
                coeff = xCoeff(iw1);
              else
                coeff = yCoeff(iw2);

              if( coeff != 0. )
              {
                 getGlobalIndex( i1+iw1,i2+iw2,i3,psim, ig );
                 // Insert coefficients of lambda*psi.x or lambda*psi.y 
                 ierr = MatSetValue(B,ig0,ig, coeff,INSERT_VALUES);CHKERRQ(ierr);   // flip sign *fix me*
               }
            }
          }
        } 
      }// end For 3d
    }
  } // end for boundary 


  if( eigOption==0 )
  {
    // ****OLD WAY***
    // FILL in a small value instead of zero
    const real smallValue = eigOption==0 ? tol/( SQR(dx[0]) ) : 0.; // 1.e-8; 
    ForBoundary(side,axis)
    {
      is1=is2=is3=0; isv[axis]=1-2*side;   // +1 on left and -1 on right       
      getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
      FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
      {
        for( int n=0; n<numberOfComponents; n++ )
        {        
          getGlobalIndex( i1,i2,i3,n, ig0 );
          // printF("Boundary B: ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);
          ierr = MatSetValue(B,ig0,ig0, smallValue,INSERT_VALUES);CHKERRQ(ierr);
        }  
      }          
    } 

    // --- fill in ghost points (constraints) ----
    ForBoundary(side,axis)
    {
      is1=is2=is3=0; isv[axis]=1-2*side;   // +1 on left and -1 on right 
      getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
      FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
      {
        for( int ghost=1; ghost<=numGhost; ghost++ )
        {
          int j1 = i1 -is1*ghost, j2 = i2 -is2*ghost,  j3 = i3;  // ghost point
          for( int n=0; n<numberOfComponents; n++ )
          {          
            getGlobalIndex( j1,j2,j3,n, ig0 );
            // printF("B Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);
            ierr = MatSetValue(B,ig0,ig0, smallValue,INSERT_VALUES);CHKERRQ(ierr);   
          }          
        }
      }          
    }  

    // --- fill corners ----
    for( int side2=0; side2<=1; side2++ ) 
    {
      for( int side1=0; side1<=1; side1++ ) 
      {
        is1=1-2*side1; is2=1-2*side2; is3=0;
        i1 = gid(side1,0); i2=gid(side2,1); i3=0; // corner point 
        for( int ghost2=1; ghost2<=numGhost; ghost2++ )
        {
          for( int ghost1=1; ghost1<=numGhost; ghost1++ )
          {
            int j1 = i1 -is1*ghost1, j2 = i2 -is2*ghost2, j3 = i3;  // ghost point
            for( int n=0; n<numberOfComponents; n++ )
            {                
              getGlobalIndex( j1,j2,j3,n, ig0 );
              // printF("B Corner Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);
              ierr = MatSetValue(B,ig0,ig0, smallValue,INSERT_VALUES);CHKERRQ(ierr);  
            }                
          }
        }
      }
    }
  }

  ierr = MatAssemblyBegin(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  ierr = MatAssemblyEnd(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);

  if( saveMatlab )
  {
    PetscViewer viewer;
    PetscObjectSetName((PetscObject)B, "B");

    PetscViewerASCIIOpen(PETSC_COMM_WORLD,"eigMatB.m",&viewer);
    PetscViewerPushFormat(viewer, PETSC_VIEWER_ASCII_MATLAB);    

    MatView(B,viewer);

    printF("Saved Matrix B to file=[eigMatB.m]\n");

    // PetscViewerPopFormat(viewer);
  }


  return 0;
}

// ==================================================================================
// Compute the eigenvalues using SLEPc
// ==================================================================================
int
computeEigenvalues( const aString & problem, const int numberOfComponents,
                    int orderOfAccuracy, int numEigenValues, int numEigenVectors, 
                    RealArray & eig, realMappedGridFunction & u, Real tol, int eigOption,
                    IntegerArray & bc, int numGhost, int saveMatlab  )
{

  printF(" ===== computeEigenvalues: problem=%s, orderOfAccuracy=%d, numberOfComponents=%d eigOption=%d =====\n",
       (const char*)problem,orderOfAccuracy, numberOfComponents,eigOption);

  Mat            A,B;             /* matrices */
  EPS            eps;             /* eigenproblem solver context */
  EPSType        type;
  Vec            xr,xi,*Iv,*Cv;
  PetscInt       nev,maxit,i,its,lits,nconv,nini=0,ncon=0;
  char           filename[PETSC_MAX_PATH_LEN];
  PetscViewer    viewer;
  PetscBool      flg,evecs,ishermitian;
  PetscErrorCode ierr;

  // SlepcInitialize(&argc,&argv,(char*)0,help);


  PetscBool      flag;
  int j,N,m,n,Istart,Iend,II;

  // ierr = PetscOptionsGetInt(NULL,"-n",&n,NULL);CHKERRQ(ierr);
  // ierr = PetscOptionsGetInt(NULL,"-m",&m,&flag);CHKERRQ(ierr);
  // if (!flag) m=n;

  MappedGrid & mg = *u.getMappedGrid();
  const bool isRectangular = mg.isRectangular();
  real dx[3]={1.,1.,1.};
  if( isRectangular )
    mg.getDeltaX(dx);

  assert( isRectangular );

  const IntegerArray & gid = mg.gridIndexRange();
  // n = gid(1,0)-gid(0,0)+1 - 2;
  // m = gid(1,1)-gid(0,1)+1 - 2;

  // ----- Number of ghost points ----
  // const int numGhost= orderOfAccuracy/2;


  const int nd1a = gid(1,0)-gid(0,0)+1 + 2*numGhost;
  const int nd2a = gid(1,1)-gid(0,1)+1 + 2*numGhost;
  const int n1a = gid(0,0)-numGhost;
  const int n2a = gid(0,1)-numGhost;
  const int n1b = gid(1,0)+numGhost;
  const int n2b = gid(1,1)+numGhost;  

  int i1,i2,i3;

  bool useNew=true;


  // N = n*m;
  N = nd1a*nd2a*numberOfComponents; // total number of grid points

  ierr = PetscPrintf(PETSC_COMM_WORLD,"\n Generalized Eigenvalue Problem Ax = k Bx, N=%D (%Dx%D grid)\n\n",
                     N,(n1b-n1a+1),(n2b-n2a+1));CHKERRQ(ierr);



   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   //      Load the matrices that define the eigensystem, Ax=kBx
   //   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

//   ierr = PetscPrintf(PETSC_COMM_WORLD,"\nGeneralized eigenproblem stored in file.\n\n");CHKERRQ(ierr);
//   ierr = PetscOptionsGetString(NULL,"-f1",filename,PETSC_MAX_PATH_LEN,&flg);CHKERRQ(ierr);
//   if (!flg) SETERRQ(PETSC_COMM_WORLD,1,"Must indicate a file name for matrix A with the -f1 option");

// #if defined(PETSC_USE_COMPLEX)
//   ierr = PetscPrintf(PETSC_COMM_WORLD," Reading COMPLEX matrices from binary files...\n");CHKERRQ(ierr);
// #else
//   ierr = PetscPrintf(PETSC_COMM_WORLD," Reading REAL matrices from binary files...\n");CHKERRQ(ierr);
// #endif
//   ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_READ,&viewer);CHKERRQ(ierr);
//   ierr = MatCreate(PETSC_COMM_WORLD,&A);CHKERRQ(ierr);
//   ierr = MatSetFromOptions(A);CHKERRQ(ierr);
//   ierr = MatLoad(A,viewer);CHKERRQ(ierr);
//   ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);

//   ierr = PetscOptionsGetString(NULL,"-f2",filename,PETSC_MAX_PATH_LEN,&flg);CHKERRQ(ierr);
//   if (flg) {
//     ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_READ,&viewer);CHKERRQ(ierr);
//     ierr = MatCreate(PETSC_COMM_WORLD,&B);CHKERRQ(ierr);
//     ierr = MatSetFromOptions(B);CHKERRQ(ierr);
//     ierr = MatLoad(B,viewer);CHKERRQ(ierr);
//     ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
//   } else {
//     ierr = PetscPrintf(PETSC_COMM_WORLD," Matrix B was not provided, setting B=I\n\n");CHKERRQ(ierr);
//     B = NULL;
//   }


  // ---- Fill Matrix A and B for the minus Laplacian ----
  if( problem=="laplace" )
  {
    fillMatrixLaplacian( orderOfAccuracy, mg, A, B, numGhost, useNew, tol, eigOption,bc, saveMatlab );
  }
  else if( problem=="ile" )
  {
    fillMatrixIncompressibleElasticity( numberOfComponents, orderOfAccuracy, mg, A, B, numGhost, useNew, tol, 
                                        eigOption,bc,saveMatlab );
  }
  else
  {
    OV_ABORT("ERROR: unknown problem");
  }

  // // ----- MATRIX A -----

  // ierr = MatCreate(PETSC_COMM_WORLD,&A);CHKERRQ(ierr);
  // ierr = MatSetSizes(A,PETSC_DECIDE,PETSC_DECIDE,N,N);CHKERRQ(ierr);
  // ierr = MatSetFromOptions(A);CHKERRQ(ierr);
  // ierr = MatSetUp(A);CHKERRQ(ierr);

  // ierr = MatGetOwnershipRange(A,&Istart,&Iend);CHKERRQ(ierr);

  // Real dx2i = 1./(dx[0]*dx[0]);
  // Real dy2i = 1./(dx[1]*dx[1]);
  // Real diag = 2.*dx2i + 2.*dy2i; 
  // for (II=Istart;II<Iend;II++) {
  //   i = II/n; j = II-i*n;
  //   if (i>0) {   ierr = MatSetValue(A,II,II-n,-dy2i,INSERT_VALUES);CHKERRQ(ierr); }
  //   if (i<m-1) { ierr = MatSetValue(A,II,II+n,-dy2i,INSERT_VALUES);CHKERRQ(ierr); }

  //   if (j>0) {   ierr = MatSetValue(A,II,II-1,-dx2i,INSERT_VALUES);CHKERRQ(ierr); }
  //   if (j<n-1) { ierr = MatSetValue(A,II,II+1,-dx2i,INSERT_VALUES);CHKERRQ(ierr); }

  //   ierr =              MatSetValue(A,II,II  , diag,INSERT_VALUES);CHKERRQ(ierr);

  //   // if (i>0) { ierr = MatSetValue(A,II,II-n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (i<m-1) { ierr = MatSetValue(A,II,II+n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (j>0) { ierr = MatSetValue(A,II,II-1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (j<n-1) { ierr = MatSetValue(A,II,II+1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // ierr = MatSetValue(A,II,II,4.0,INSERT_VALUES);CHKERRQ(ierr);

  // }

  // ierr = MatAssemblyBegin(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  // ierr = MatAssemblyEnd(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);



  // // ----- MATRIX B = I -----

  // ierr = MatCreate(PETSC_COMM_WORLD,&B);CHKERRQ(ierr);
  // ierr = MatSetSizes(B,PETSC_DECIDE,PETSC_DECIDE,N,N);CHKERRQ(ierr);
  // ierr = MatSetFromOptions(B);CHKERRQ(ierr);
  // ierr = MatSetUp(B);CHKERRQ(ierr);

  // ierr = MatGetOwnershipRange(B,&Istart,&Iend);CHKERRQ(ierr);
  // for (II=Istart;II<Iend;II++) {
  //   i = II/n; j = II-i*n;
  //   // if (i>0) { ierr = MatSetValue(B,II,II-n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (i<m-1) { ierr = MatSetValue(B,II,II+n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (j>0) { ierr = MatSetValue(B,II,II-1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (j<n-1) { ierr = MatSetValue(B,II,II+1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   ierr = MatSetValue(B,II,II,1.0,INSERT_VALUES);CHKERRQ(ierr);
  // }

  // ierr = MatAssemblyBegin(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  // ierr = MatAssemblyEnd(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);



  ierr = MatGetVecs(A,NULL,&xr);CHKERRQ(ierr);
  ierr = MatGetVecs(A,NULL,&xi);CHKERRQ(ierr);

  /*
     Read user constraints if available
  */
  ierr = PetscOptionsGetInt(NULL,"-nconstr",&ncon,&flg);CHKERRQ(ierr);
  if (flg) {
    if (ncon<=0) SETERRQ(PETSC_COMM_WORLD,1,"The number of constraints must be >0");
    ierr = PetscOptionsGetString(NULL,"-fconstr",filename,PETSC_MAX_PATH_LEN,&flg);CHKERRQ(ierr);
    if (!flg) SETERRQ(PETSC_COMM_WORLD,1,"Must specify the name of the file storing the constraints");
    ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_READ,&viewer);CHKERRQ(ierr);
    ierr = VecDuplicateVecs(xr,ncon,&Cv);CHKERRQ(ierr);
    for (i=0;i<ncon;i++) {
      ierr = VecLoad(Cv[i],viewer);CHKERRQ(ierr);
    }
    ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
  }

  /*
     Read initial guesses if available
  */
  ierr = PetscOptionsGetInt(NULL,"-ninitial",&nini,&flg);CHKERRQ(ierr);
  if (flg) {
    if (nini<=0) SETERRQ(PETSC_COMM_WORLD,1,"The number of initial vectors must be >0");
    ierr = PetscOptionsGetString(NULL,"-finitial",filename,PETSC_MAX_PATH_LEN,&flg);CHKERRQ(ierr);
    if (!flg) SETERRQ(PETSC_COMM_WORLD,1,"Must specify the name of the file containing the initial vectors");
    ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_READ,&viewer);CHKERRQ(ierr);
    ierr = VecDuplicateVecs(xr,nini,&Iv);CHKERRQ(ierr);
    for (i=0;i<nini;i++) {
      ierr = VecLoad(Iv[i],viewer);CHKERRQ(ierr);
    }
    ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                Create the eigensolver and set various options
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /*
     Create eigensolver context
  */
  ierr = EPSCreate(PETSC_COMM_WORLD,&eps);CHKERRQ(ierr);

  /*
     Set operators. In this case, it is a generalized eigenvalue problem
  */
  if( eigOption==0 )
  {
     // Solve A x = k B x
    ierr = EPSSetOperators(eps,A,B);CHKERRQ(ierr);
  }
  else
  {
     // Solve B x = k A x
    ierr = EPSSetOperators(eps,B,A);CHKERRQ(ierr);
  }

  /*
     If the user provided initial guesses or constraints, pass them here
  */
  ierr = EPSSetInitialSpace(eps,nini,Iv);CHKERRQ(ierr);
  ierr = EPSSetDeflationSpace(eps,ncon,Cv);CHKERRQ(ierr);

  // ---- choose eigenvalues to find ----
  if( eigOption==0 )
  {
    ierr = EPSSetWhichEigenpairs(eps,EPS_SMALLEST_MAGNITUDE); CHKERRQ(ierr);
  }
  else
  {
    ierr = EPSSetWhichEigenpairs(eps,EPS_LARGEST_MAGNITUDE); CHKERRQ(ierr);
  }

  PetscInt maxIt = 10000; 
  ierr = EPSSetTolerances(eps,tol,maxIt); CHKERRQ(ierr);

  /*
     Set solver parameters at runtime
  */
  ierr = EPSSetFromOptions(eps);CHKERRQ(ierr);

  PetscInt mpd = PETSC_DEFAULT; // numEigenVectors; // maximum projected dimension, decrease to save space
  printF("Setting numEigenValues=%d, numEigenVectors=%d,\n",numEigenValues,numEigenVectors);
  PetscInt ncv = PETSC_DEFAULT; // numEigenValues*2+1; // size of column space 
  ierr = EPSSetDimensions(eps,numEigenValues,ncv,mpd); CHKERRQ(ierr);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                      Solve the eigensystem
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  ierr = EPSSolve(eps);CHKERRQ(ierr);

  /*
     Optional: Get some information from the solver and display it
  */
  ierr = EPSGetIterationNumber(eps,&its);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD," Number of iterations of the method: %D\n",its);CHKERRQ(ierr);
  ierr = EPSGetOperationCounters(eps,NULL,NULL,&lits);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD," Number of linear iterations of the method: %D\n",lits);CHKERRQ(ierr);
  ierr = EPSGetType(eps,&type);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD," Solution method: %s\n\n",type);CHKERRQ(ierr);

  ierr = EPSGetDimensions(eps,&nev,NULL,NULL);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD," Number of requested eigenvalues: %D\n",nev);CHKERRQ(ierr);

  nev = numEigenValues;

  ierr = EPSGetTolerances(eps,&tol,&maxit);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD," Stopping condition: tol=%.4G, maxit=%D\n",tol,maxit);CHKERRQ(ierr);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                    Display solution and clean up
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  ierr = EPSPrintSolution(eps,NULL);CHKERRQ(ierr);
  /*
     Save eigenvectors, if requested
  */
  ierr = PetscOptionsGetString(NULL,"-evecs",filename,PETSC_MAX_PATH_LEN,&evecs);CHKERRQ(ierr);

  ierr = EPSGetConverged(eps,&nconv);CHKERRQ(ierr);
  if( nconv>0 && nev>0 ) 
  {
    // ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_WRITE,&viewer);CHKERRQ(ierr);
    // ierr = EPSIsHermitian(eps,&ishermitian);CHKERRQ(ierr);
    // for (i=0;i<nconv;i++) 
    eig.redim(2,numEigenVectors);

    for( int i=0; i<numEigenVectors; i++ ) 
    {

      PetscScalar kr, ki;
      ierr = EPSGetEigenpair(eps,i,&kr,&ki,xr,xi); CHKERRQ(ierr);
      if( eigOption==0 )
      {
        eig(0,i) = kr;
        eig(1,i) = ki;
      }
      else
      {
        // 1/z = zBar/ |z|^2 
        eig(0,i) =  kr/( kr*kr + ki*ki );
        eig(1,i) = -ki/( kr*kr + ki*ki );
      }

      // printF("Eigenvalue %d : k=%18.14e + %18.14e I \n",i,kr,ki);

      // ierr = EPSGetEigenvector(eps,i,xr,xi);CHKERRQ(ierr);

      // ierr = VecView(xr,viewer);CHKERRQ(ierr);
      // if (!ishermitian) { ierr = VecView(xi,viewer);CHKERRQ(ierr); }

      if( i<numEigenVectors )
      {
        // ---- Save the first eigenvector ----
        // printF("Save eigenvector %d to the grid function.\n",i);

        PetscScalar *xrv;
        VecGetArray(xr,&xrv);  // get the local array from Petsc
        ierr = VecGetOwnershipRange(xr,&Istart,&Iend);CHKERRQ(ierr);


        for(int II=Istart; II<Iend; II++ ) 
        {
          getLocalIndex( II,i1,i2,i3,n ); 
          // printF("II=%d, i1=%d, i2=%d\n",II,i1,i2);

          assert( i1>=n1a && i1<=n1b && i2>=n2a && i2<=n2b && n>=0 && n<numberOfComponents );
          const int nComp = n + numberOfComponents*(i); 
          u(i1,i2,i3,nComp) = xrv[II];
        }


      }
    }
    // ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
  }

  /*
     Free work space
  */
  ierr = EPSDestroy(&eps);CHKERRQ(ierr);
  ierr = MatDestroy(&A);CHKERRQ(ierr);
  ierr = MatDestroy(&B);CHKERRQ(ierr);
  ierr = VecDestroy(&xr);CHKERRQ(ierr);
  ierr = VecDestroy(&xi);CHKERRQ(ierr);
  if (nini > 0) {
    ierr = VecDestroyVecs(nini,&Iv);CHKERRQ(ierr);
  }
  if (ncon > 0) {
    ierr = VecDestroyVecs(ncon,&Cv);CHKERRQ(ierr);
  }
  // ierr = SlepcFinalize();


}// end compute Eigenvalues 


// ==================================================================================
/// \brief Compute the pressure from the displacement
// ==================================================================================
int getPressureFromDisplacement( realCompositeGridFunction & uv, realCompositeGridFunction & p, 
                                IntegerArray & bc, int orderOfAccuracy, real mu  )
{
  CompositeGrid & cg = *uv.getCompositeGrid();
  const int numberOfDimensions = cg.numberOfDimensions();

  Oges solver( cg ); 
                      // create a solver
  // solver.set(OgesParameters::THEsolverType,solverType);

  int stencilSize = orderOfAccuracy+1;
  CompositeGridOperators op(cg);                            // create some differential operators
  op.setStencilSize(stencilSize);
  op.setOrderOfAccuracy(orderOfAccuracy);  

  IntegerArray boundaryConditions(2,3,cg.numberOfComponentGrids());
  RealArray bcData(2,2,3,cg.numberOfComponentGrids());
  boundaryConditions=OgesParameters::neumann;
  for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
  {
    MappedGrid & mg = cg[grid];  
    ForBoundary(side,axis)
    {
      if( bc(side,axis)==displacement )
        boundaryConditions(side,axis,grid)=OgesParameters::neumann;
      else if( bc(side,axis)==traction )
        boundaryConditions(side,axis,grid)=OgesParameters::dirichlet;
    }
  }

  bcData=0.;
  solver.setEquationAndBoundaryConditions( OgesParameters::laplaceEquation,op,boundaryConditions,bcData);

  Range all;
  realCompositeGridFunction f(cg,all,all,all);

  f=0.;

  Index Ib1,Ib2,Ib3;
  Index Ig1,Ig2,Ig3;
  // ---- Assign boundary conditions ----
  for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
  {
    MappedGrid & mg = cg[grid];
    realMappedGridFunction & uvg = uv[grid];
    OV_GET_SERIAL_ARRAY(real,f[grid],fLocal);

    ForBoundary(side,axis)
    {
      getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
      getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3);
      if( bc(side,axis)==displacement )
      {

        // Displacement BC: p.n = n.( mu *(u.xx + u.yy)
        int is=1-2*side; 
        if( axis==0 )
        {
          fLocal(Ig1,Ig2,Ig3) = (-is*mu)*uvg.xx(Ib1,Ib2,Ib3,0)(Ib1,Ib2,Ib3,0);
        }
        else
        {
          fLocal(Ig1,Ig2,Ig3) = (-is*mu)*uvg.yy(Ib1,Ib2,Ib3,1)(Ib1,Ib2,Ib3,1);
        }
        // ::display(fLocal(Ig1,Ig2,Ig3),"f(boundary) = mu*u1.xx","%9.2e ");
        // printF("getPressure: set pressure displacement BC on (side,axis)=(%d,%d) max(|f|)=%e\n",side,axis,
        //      max(fabs(fLocal(Ig1,Ig2,Ig3))) );        
      }
      else if( bc(side,axis)==traction )
      {
        // Traction BC: p = 2*mu*u.x : x=0
        //                = 2*mu*v.y : y=0 
        if( axis==0 )
        {
          fLocal(Ib1,Ib2,Ib3) = (2.*mu)*uvg.x(Ib1,Ib2,Ib3,0)(Ib1,Ib2,Ib3,0);
        }
        else
        {
          fLocal(Ib1,Ib2,Ib3) = (2.*mu)*uvg.y(Ib1,Ib2,Ib3,1)(Ib1,Ib2,Ib3,1);
        }
        // ::display(fLocal(Ib1,Ib2,Ib3),"f(boundary) = 2*mu*u1.x","%9.2e ");
        // printF("getPressure: set pressure traction BC on (side,axis)=(%d,%d) max(|f|)=%e\n",side,axis,
        //      max(fabs(fLocal(Ib1,Ib2,Ib3))) );
      }
    }
  }

  p=0.;  // initial guess for iterative solvers
  real time0=getCPU();
  solver.solve( p,f );   // solve the equations
  real time= ParallelUtility::getMaxValue(getCPU()-time0);
  printF("\n*** getPressureFromDisplacement : max residual=%8.2e, time for pressure solve = %8.2e (iterations=%i) ***\n",
         solver.getMaximumResidual(),time,solver.getNumberOfIterations());


  return 0;
}


// =================================================================
/// \brief Return the name of the boundary condition.
// =================================================================
aString bcName( int bc )
{
  if( bc==-1 )
    return "p";
  else if( bc==0 )
    return "i"; // interp
  else if( bc==1 )
    return "d"; // displacement
  else if( bc==2 )
    return "t"; // traction
  else
    return "u"; // unknown

}

// =========================================================
// Macro: set a BC from a command line argument
// =========================================================
#beginMacro setBC(side,axis)
  aString bcChar = arg(len,arg.length()-1);
  if( bcChar=="d" )
    bc(side,axis)=displacement;
  else if( bcChar=="t" )
    bc(side,axis)=traction;
  else
  {
    printF("setBC: Unknown bc=[%s]\n",(const char*)bcChar);
    OV_ABORT("error");
  }
  printF("Setting bc(side,axis)=%s\n",(const char*)bcName(bc(side,axis)));

#endMacro

// ==================================================================================
// ================================ MAIN ============================================
// ==================================================================================
int main(int argc,char **argv)
{

  Overture::start(argc,argv);  // initialize Overture

  SlepcInitialize(&argc,&argv,(char*)0,help);  

  aString commandFileName="";
  aString problem = "laplace"; 
  bool plotOption=true;
  aString nameOfShowFile=""; 

  int debug=0;
  int numPoints=101;
  int nx=52, ny=52; 
  int numEigenValues  = 1; // number of eigenvalues to compute 
  int numEigenVectors = 1; // number of eigenvectors to save
  int orderOfAccuracy = 2 ;
  real tol=1.e-8; 

  real rho=1., mu=1.;

  int includePressure=0;  // solve for pressure as well as psi

  int saveMatlab=0;       // 1 = save A and B matrices to matlab format


  IntegerArray bc(2,3);
  bc = displacement; 

  // eigOption = 0 : =solve Ax =kBx for smallest k, 
  //           = 1 : solve Bx = k A x for largest k 
  int eigOption = 0;
  Real eigSign = 1.;  // use to change sign of the eigenfunction
  
  int eigc=0; // which eigen-vector to choose **make this an option***

  real xa=0., xb=1., ya=0., yb=1.;

  printF("Usage: genEigs [-debug=<i>]\n");
  int len=0;
  if( argc > 1 )
  { 
    for( int i=1; i<argc; i++ )
    {
      aString arg = argv[i];
      if( arg=="-noplot" || arg=="noplot" )
      {
        plotOption=false;
      }
      else if( (len=arg.matches("-problem="))  )
      {
        problem = arg(len,arg.length()-1);
        printF("Setting problem=[%s]\n",(const char*)problem);
      }
      else if( (len=arg.matches("-show="))  )
      {
        nameOfShowFile = arg(len,arg.length()-1);
        printF("Setting nameOfShowFile=[%s]\n",(const char*)nameOfShowFile);
      }      
      else if( arg(0,6)=="-debug=" )
      {
        sScanF(arg(7,arg.length()-1),"%i",&debug);
        printF("Setting debug=%i\n",debug);
      }
      else if( (len=arg.matches("-orderOfAccuracy="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&orderOfAccuracy);
        printF("Setting orderOfAccuracy=%d\n",orderOfAccuracy);
      }
      else if( (len=arg.matches("-order="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&orderOfAccuracy);
        printF("Setting orderOfAccuracy=%d\n",orderOfAccuracy);
      } 

      else if( (len=arg.matches("-includePressure="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&includePressure);
        printF("Setting includePressure=%d\n",includePressure);
      }  

      else if( (len=arg.matches("-eigOption="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&eigOption);
        printF("Setting eigOption=%d\n",eigOption);
      }  

      else if( (len=arg.matches("-eigc="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&eigc);
        printF("Setting eigc=%d\n",eigc);
      }     
      else if( (len=arg.matches("-saveMatlab="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&saveMatlab);
        printF("Setting saveMatlab=%d\n",saveMatlab);
      }                        

      else if( (len=arg.matches("-bc1="))  )
      {
        setBC(0,0);
      }
      else if( (len=arg.matches("-bc2="))  )
      {
        setBC(1,0);
      }
      else if( (len=arg.matches("-bc3="))  )
      {
        setBC(0,1);
      }
      else if( (len=arg.matches("-bc4="))  )
      {
        setBC(1,1);
      }

       

      else if( (len=arg.matches("-nx="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&nx);
        printF("Setting nx=%d\n",nx);
      }

      else if( (len=arg.matches("-tol="))  )
      {
        sScanF(arg(len,arg.length()-1),"%e",&tol);
        printF("Setting tol=%e\n",tol);
      }

      else if( (len=arg.matches("-xb="))  )
      {
        sScanF(arg(len,arg.length()-1),"%e",&xb);
        printF("Setting xb=%e\n",xb);
      }      
      else if( (len=arg.matches("-yb="))  )
      {
        sScanF(arg(len,arg.length()-1),"%e",&yb);
        printF("Setting yb=%e\n",yb);
      }  

      else if( (len=arg.matches("-eigSign="))  )
      {
        sScanF(arg(len,arg.length()-1),"%e",&eigSign);
        printF("Setting eigSign=%e\n",eigSign);
      }

      else if( (len=arg.matches("-ny="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&ny);
        printF("Setting ny=%d\n",ny);
      }
      else if( (len=arg.matches("-numEigenValues="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&numEigenValues);
        printF("Setting numEigenValues=%d\n",numEigenValues);
      }          
      else if( (len=arg.matches("-numEigenVectors="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&numEigenVectors);
        printF("Setting numEigenVectors=%d\n",numEigenVectors);
      }         
      else if( commandFileName=="" )
      {
        commandFileName=arg;    
        printf("genEigs: reading commands from file [%s]\n",(const char*)commandFileName);
      }
    }
  }
  else
  {
    printF("Usage: `genEigs [-noplot] [-g=<gridName>] [file.cmd] [-debug=<value>] ' \n");
  }
  
  GenericGraphicsInterface & gi = *Overture::getGraphicsInterface("genEigs",plotOption,argc,argv);
  PlotStuffParameters psp;

  // By default start saving the command file called:
  aString logFile="genEigs.cmd";
  gi.saveCommandFile(logFile);
  printF("User commands are being saved in the file `%s'\n",(const char *)logFile);

  aString outputFileName="genEigs.log";
  FILE *outFile = NULL;
  

  // read from a command file if given
  if( commandFileName!="" )
  {
    printF("read command file =[%s].\n",(const char*)commandFileName);
    gi.readCommandFile(commandFileName);
  }


  const int numberOfDimensions=2;

  int numGhost = orderOfAccuracy/2;

  if( min(abs(bc-traction))==0 )
  {
    // includePressure=1;  // traction BCs need the pressure --> no more
    numGhost++;         // and one more ghost line
  }
  else
  {
    // numGhost++; // TEST
  }

  int numberOfComponents=1;
  if( problem=="laplace" )
  {
    numberOfComponents=1;
  }
  else if( problem=="ile" )
  {
    // Incompressible elasticity
    if( includePressure )
    {
      numberOfComponents=2; 
    }
  }
  else
  {
   OV_ABORT("ERROR: unknown problem");
  }

  SquareMapping square(xa,xb,ya,yb);                   // Make a mapping
  square.setGridDimensions(axis1,nx);                  // axis1==0, set no. of grid points
  square.setGridDimensions(axis2,ny);                  // axis2==1, set no. of grid points

  MappedGrid mg(square);   
  ForBoundary(side,axis)
  {
    if( side==1 && axis==(numberOfDimensions-1) )
      mg.setNumberOfGhostPoints(side,axis,numGhost+1);  // add one for extra equations
    else
      mg.setNumberOfGhostPoints(side,axis,numGhost);
  }    

  // Make a CompositeGrid                        
  CompositeGrid cg(mg.numberOfDimensions(),1);
  cg[0].reference(mg);   
  cg.updateReferences();

  cg.update(MappedGrid::THEmask | MappedGrid::THEvertex | MappedGrid::THEcenter);  

  
  Range all;       
  int totalNumberOfComponents = numEigenVectors*numberOfComponents;
  realMappedGridFunction u(mg,all,all,all,totalNumberOfComponents);  // create a grid function
  u.setName("v");                 // give names to grid function ...
  for( int i=0, k=0; i<numEigenVectors; i++ )
  {
    if( numberOfComponents==1 )
    {
      u.setName(sPrintF("psi%d",i), i);
    }
    else
    {
      assert( numberOfComponents==2 );
      u.setName(sPrintF("psi%d",i), k); k++;  // first component is psi 
      u.setName(sPrintF("p%d",i), k); k++;  // 2nd component is p 

      // for( int j=0; j<numberOfComponents; j++ )
      // {
      //   u.setName(sPrintF("v%d_%d",i,j),k); k++; 
      // }
    }
  }
  Index I1,I2,I3; 
  getIndex(mg.dimension(),I1,I2,I3);                        // assign I1,I2,I3 from dimension

  u=0.;
  // u(I1,I2,I3,0)=sin(Pi*mg.vertex()(I1,I2,I3,axis1))         // component 0 : sin(pi*x)*cos(pi*y)
  //              *cos(Pi*mg.vertex()(I1,I2,I3,axis2));        
  // u(I1,I2,I3,1)=cos(Pi*mg.vertex()(I1,I2,I3,axis1))         // component 1 : cos(pi*x)*sin(pi*y)
  //              *sin(Pi*mg.vertex()(I1,I2,I3,axis2));       

 

  CompositeGridOperators cgop(cg);
  cgop.setOrderOfAccuracy(orderOfAccuracy);
  MappedGridOperators & op = cgop[0];

  u.setOperators(op);

  const int u1c=0, u2c=1, pc=2, psic=3;
  realCompositeGridFunction uv(cg,all,all,all,numberOfDimensions+2);
  uv.setName("u1",u1c);  
  uv.setName("u2",u2c);  
  uv.setName("p",pc); 
  uv.setName("psi",psic); 
  uv.setOperators(cgop);
  realCompositeGridFunction p(cg,all,all,all);
  p.setName("p",0);
  p.setOperators(cgop);

  // // Create the object that knows how to evaluate the boundary of the eye-lid
  // EyeCurves eyeCurves;
  
  real time=0.; // plot curve at this time
  
  // ========== create the GUI and dialog ================
  GUIState dialog;
  dialog.setWindowTitle("Eigenvalues Code");
  dialog.setExitCommand("exit", "exit");

  aString cmds[] = {"compute",
                    "contour",
                    "check",
                    "erase",
                    "save file",
                    "" };
  int numberOfPushButtons=0;  // number of entries in cmds
  while( cmds[numberOfPushButtons]!="" ){numberOfPushButtons++;}; // 
  int numRows=(numberOfPushButtons+1)/2;
  dialog.setPushButtons( cmds, cmds, numRows ); 

  const int numberOfTextStrings=15;  // max number allowed
  aString textLabels[numberOfTextStrings];
  aString textStrings[numberOfTextStrings];

  int nt=0;
  textLabels[nt] = "time:";  sPrintF(textStrings[nt],"%g",time);  nt++; 
  textLabels[nt] = "numPoints:";  sPrintF(textStrings[nt],"%i",numPoints);  nt++; 
  // null strings terminal list
  textLabels[nt]="";   textStrings[nt]="";  assert( nt<numberOfTextStrings );
  dialog.setTextBoxes(textLabels, textLabels, textStrings);

  gi.pushGUI(dialog);
  gi.appendToTheDefaultPrompt("genEigs>");
  psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,true);

  RealArray eig; 
 
  aString answer,buff;  
  for( ;; )
  {
    gi.getAnswer(answer,"");  
 
    if( answer=="continue" )
    {
      break;
    }
    else if( answer=="exit" || answer=="done" )
    {
      break;
    }
    else if( answer=="compute" )
    {
      computeEigenvalues( problem,numberOfComponents, orderOfAccuracy, numEigenValues,numEigenVectors, eig, 
                          u, tol, eigOption,bc, numGhost, saveMatlab );

      printF("\n======================== GenEigs problem=%s =======================\n",(const char*)problem);
      printF(" nx=%d, ny=%d, orderOfAccuracy=%d, numberOfComponents=%d numGhost=%d \n",
            nx,ny,orderOfAccuracy,numberOfComponents,numGhost);
      printF(" bc = [%s,%s,%s,%s]\n",(const char*)bcName(bc(0,0)),(const char*)bcName(bc(1,0)),
                                     (const char*)bcName(bc(0,1)),(const char*)bcName(bc(1,1))); 
      printF("===================================================================\n");
      for( int i=0; i<numEigenVectors; i++ )
      {
        printF("Eigenvalue %d : k=%18.14e + %18.14e I",i,eig(0,i),eig(1,i));
        if( problem=="laplace" && i<=6 )
        {
          // --- Eigenvalues of the -Laplacian on the unit square ---
          real eigTrue = i==0 ? 2*Pi*Pi : 
                         i==1 ? SQR(Pi) + SQR(2.*Pi) :
                         i==2 ? SQR(Pi) + SQR(2.*Pi) : 
                         i==3 ? SQR(2.*Pi) + SQR(2.*Pi) :
                         i==4 ? SQR(3.*Pi) + SQR(1.*Pi) :
                         i==5 ? SQR(3.*Pi) + SQR(1.*Pi) :
                                SQR(2.*Pi) + SQR(3.*Pi) ;
          printF(",  true=%18.14e, err=%8.2e",eigTrue,fabs(eig(0,i)-eigTrue));
        }
        printF("\n");
      }
    }    
    else if( answer=="contour" )
    {
      gi.erase();
      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,false);      
      psp.set(GI_TOP_LABEL,sPrintF("Eigenvector"));  // set title
      PlotIt::contour(gi, u,psp );
      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,true);      
    }    
    else if( dialog.getTextValue(answer,"time:","%g",time) ){}// 
    else if( dialog.getTextValue(answer,"numPoints:","%i",numPoints) ){}// 
    else if( answer=="erase" )
    {
      gi.erase();
    }
    else if( answer=="check" && problem=="ile" )
    {  

      // --- check the ILE solution ----
      printF("--- check the incompressible elasticity solution : eigc=%d---\n",eigc);

      // eigenvalue: 
      const Real lambda = eig(0,eigc);  

      const int psim = 0 + numberOfComponents*(eigc); // index for psi
      const int pm   = 1 + numberOfComponents*(eigc); // index for p             


      Index Iv[3],  &I1  =Iv[0], &I2  =Iv[1], &I3=  Iv[2];
      Index Ibv[3], &Ib1=Ibv[0], &Ib2=Ibv[1], &Ib3=Ibv[2];
      Index Igv[3], &Ig1=Igv[0], &Ig2=Igv[1], &Ig3=Igv[2];
      BoundaryConditionParameters extrapParams;
      extrapParams.orderOfExtrapolation=orderOfAccuracy+1;


      for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
      {
        MappedGrid & mg = cg[grid];
        realMappedGridFunction & uvg = uv[grid];
        realMappedGridFunction & pg  = p[grid];
        OV_GET_SERIAL_ARRAY(real,uvg,uLocal);

        const bool isRectangular = mg.isRectangular();
        real dx[3]={1.,1.,1.};
        if( isRectangular )
          mg.getDeltaX(dx);

        getIndex(mg.dimension(),I1,I2,I3);

        uv[grid](I1,I2,I3,0) =  u.y(I1,I2,I3,psim)(I1,I2,I3,psim);   // u1 =  psi.y 
        uv[grid](I1,I2,I3,1) = -u.x(I1,I2,I3,psim)(I1,I2,I3,psim);   // u2 = -psi.x 

        // First extrap all ghost 
        for( int ghost=1; ghost<=numGhost; ghost++ )
        {
          extrapParams.ghostLineToAssign=ghost;
          uvg.applyBoundaryCondition(Range(0,1),BCTypes::extrapolate,BCTypes::allBoundaries,0.,0.,extrapParams);
        }  

        if( orderOfAccuracy==2 )
        {
          // apply BC's to u1 and u2 -- maybe not needed if use use CBCs when solving for the eigenfunction
          ForBoundary(side,axis)
          {
            getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
            getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3);

            const int is = 1-2*side; 
            if( bc(side,axis)==displacement )
            {
              if( axis==0 )
              {
                // u1.x = 0 
                uvg.applyBoundaryCondition(u1c,BCTypes::neumann,    BCTypes::BCTypes::boundary(side,axis),0.);
                // uvg.applyBoundaryCondition(u2c,BCTypes::extrapolate,BCTypes::BCTypes::boundary(side,axis),0.);

                // mu*u2.xx = p.y - lambda*u2  **CHECK ME** TROUBLE: p is NOT KNOWN YET !!
                // uLocal(Ig1,Ig2,Ig3,u2c) = 2.*uLocal(Ib1,Ib2,Ib3,u2c) - uLocal(Ib1+is,Ib2,Ib3,u2c)
                //   + (SQR(dx[0])/mu)*( pg.y(Ib1,Ib2,Ib3)(Ib1,Ib2,Ib3) - lambda*uLocal(Ib1,Ib2,Ib3,u2c) );
              }
              else
              {
                // u2.y = 0 
                uvg.applyBoundaryCondition(u2c,BCTypes::neumann,    BCTypes::BCTypes::boundary(side,axis),0.);
                // uvg.applyBoundaryCondition(u1c,BCTypes::extrapolate,BCTypes::BCTypes::boundary(side,axis),0.);
                // mu*u1.yy = p.x - lambda*u1  ** CHECK ME **
                // uLocal(Ig1,Ig2,Ig3,u1c) = 2.*uLocal(Ib1,Ib2,Ib3,u1c) - uLocal(Ib1,Ib2+is,Ib3,u1c)
                //   + (SQR(dx[1])/mu)*( pg.x(Ib1,Ib2,Ib3)(Ib1,Ib2,Ib3) - lambda*uLocal(Ib1,Ib2,Ib3,u1c) ) ;             
              }
            }
            else if( bc(side,axis)==traction )
            {
              // Set v.x + u.y = 0 
              //     u.x + v.y = 0 
              // printF("Set BCs for traction BC -- finish me\n");
              if( axis==0 )
              {
                uLocal(Ib1-is,Ib2,Ib3,u1c) = uLocal(Ib1+is,Ib2,Ib3,u1c) + 
                             (is*dx[0]/dx[1])*( uLocal(Ib1,Ib2+1,Ib3,u2c) - uLocal(Ib1,Ib2-1,Ib3,u2c) );
                uLocal(Ib1-is,Ib2,Ib3,u2c) = uLocal(Ib1+is,Ib2,Ib3,u2c) + 
                             (is*dx[0]/dx[1])*( uLocal(Ib1,Ib2+1,Ib3,u1c) - uLocal(Ib1,Ib2-1,Ib3,u1c) );
              }
              else
              {
                uLocal(Ib1,Ib2-is,Ib3,u1c) = uLocal(Ib1,Ib2+is,Ib3,u1c) + 
                             (is*dx[1]/dx[0])*( uLocal(Ib1+1,Ib2,Ib3,u2c) - uLocal(Ib1-1,Ib2,Ib3,u2c) );
                uLocal(Ib1,Ib2-is,Ib3,u2c) = uLocal(Ib1,Ib2+is,Ib3,u2c) + 
                             (is*dx[1]/dx[0])*( uLocal(Ib1+1,Ib2,Ib3,u1c) - uLocal(Ib1-1,Ib2,Ib3,u1c) );

              }
            }

          }
          // ::display(uvg,"uvg after apply BC","%6.3f ");
        }
        else if( orderOfAccuracy==4 )
        {
          // apply BC's to u1 and u2 -- maybe not needed if use use CBCs when solving for the eigenfunction


          // u.x = 0 
          //   u(-2) -8*u(-1) + 8*u(1) -u(2) = 0 
          //   u(-2) = 5*u(-1) -10*u(0) +10*u(1) -5*u(2) + u(3)
          //   -3*u(1) -10*u(0) +18*u(1) -6*u(2) + u(3) = 0
          const Real cex41= (-10./3.), cex42=6., cex43=-2., cex44=1./3.; 

          ForBoundary(side,axis)
          {
            getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
            // getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3);

            const int is = 1-2*side; 
            if( bc(side,axis)==displacement )
            {
              if( axis==0 )
              {
                // u1.x = 0 
                // uvg.applyBoundaryCondition(u1c,BCTypes::neumann,    BCTypes::BCTypes::boundary(side,axis),0.);
                // uvg.applyBoundaryCondition(u2c,BCTypes::extrapolate,BCTypes::BCTypes::boundary(side,axis),0.);

                uLocal(Ib1-is,Ib2,Ib3,u1c) = cex41*uLocal(Ib1     ,Ib2,Ib3,u1c) +
                                             cex42*uLocal(Ib1+  is,Ib2,Ib3,u1c) +
                                             cex43*uLocal(Ib1+2*is,Ib2,Ib3,u1c) +
                                             cex44*uLocal(Ib1+3*is,Ib2,Ib3,u1c);
                uLocal(Ib1-2*is,Ib2,Ib3,u1c) =  5.*uLocal(Ib1-1*is,Ib2,Ib3,u1c) +
                                              -10.*uLocal(Ib1     ,Ib2,Ib3,u1c) +
                                              +10.*uLocal(Ib1+1*is,Ib2,Ib3,u1c) +
                                               -5.*uLocal(Ib1+2*is,Ib2,Ib3,u1c) +                                       
                                               +1.*uLocal(Ib1+3*is,Ib2,Ib3,u1c);                                        

                // // mu*u2.xx = p.y - lambda*u2  **CHECK ME**
                // uLocal(Ig1,Ig2,Ig3,u2c) = 2.*uLocal(Ib1,Ib2,Ib3,u2c) - uLocal(Ib1+is,Ib2,Ib3,u2c)
                //   + (SQR(dx[0])/mu)*( pg.y(Ib1,Ib2,Ib3)(Ib1,Ib2,Ib3) - lambda*uLocal(Ib1,Ib2,Ib3,u2c) );

              }
              else
              {
                // u2.y = 0 
                // uvg.applyBoundaryCondition(u2c,BCTypes::neumann,    BCTypes::BCTypes::boundary(side,axis),0.);
                uLocal(Ib1,Ib2-is,Ib3,u2c) = cex41*uLocal(Ib1,Ib2     ,Ib3,u2c) +
                                             cex42*uLocal(Ib1,Ib2+  is,Ib3,u2c) +
                                             cex43*uLocal(Ib1,Ib2+2*is,Ib3,u2c) +
                                             cex44*uLocal(Ib1,Ib2+3*is,Ib3,u2c);
                uLocal(Ib1,Ib2-2*is,Ib3,u2c) =  5.*uLocal(Ib1,Ib2-1*is,Ib3,u2c) +
                                              -10.*uLocal(Ib1,Ib2     ,Ib3,u2c) +
                                              +10.*uLocal(Ib1,Ib2+1*is,Ib3,u2c) +
                                               -5.*uLocal(Ib1,Ib2+2*is,Ib3,u2c) +                                       
                                               +1.*uLocal(Ib1,Ib2+3*is,Ib3,u2c);   

   
                // uvg.applyBoundaryCondition(u1c,BCTypes::extrapolate,BCTypes::BCTypes::boundary(side,axis),0.);
                // mu*u1.yy = p.x - lambda*u1  ** CHECK ME **
                // uLocal(Ig1,Ig2,Ig3,u1c) = 2.*uLocal(Ib1,Ib2,Ib3,u1c) - uLocal(Ib1,Ib2+is,Ib3,u1c)
                //   + (SQR(dx[1])/mu)*( pg.x(Ib1,Ib2,Ib3)(Ib1,Ib2,Ib3) - lambda*uLocal(Ib1,Ib2,Ib3,u1c) ) ;             
              }
            }
            else if( bc(side,axis)==traction )
            {
              // Set v.x + u.y = 0 
              //     u.x + v.y = 0 

              printF("Set BCs for traction BC -- finish me\n");
            }            
            // for( int ghost=2; ghost<=numGhost; ghost++ )
            // {
            //   extrapParams.ghostLineToAssign=ghost;
            //   uvg.applyBoundaryCondition(Range(0,1),BCTypes::extrapolate,BCTypes::allBoundaries,0.,0.,extrapParams);
            // }            

          }
          // ::display(uvg,"uvg after apply BC","%6.3f ");
        }
      }      

      // for now extrapolate ghost -- could do better
      // if( orderOfAccuracy>4 )
      // {
      //   for( int ghost=1; ghost<=numGhost; ghost++ )
      //   {
      //     extrapParams.orderOfExtrapolation=orderOfAccuracy+1; 
      //     extrapParams.ghostLineToAssign=ghost;
      //     uv.applyBoundaryCondition(Range(0,1),BCTypes::extrapolate,BCTypes::allBoundaries,0.,0.,extrapParams);
      //   }
      // }
      uv.finishBoundaryConditions();


      // Normalize eigen-solution (u1,u2) to have max norm of 1
      const Real scaleFactor = eigSign/max( maxNorm(uv,0), maxNorm(uv,1) );
      for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
      {
        uv[grid](all,all,all,Range(0,1)) *= scaleFactor;
      }  

      // Normalize eigen-solution psi to have max norm of 1 -- OR SHOULD WE JUST USE scaleFactor ??
      const Real psiScaleFactor = maxNorm(u,eigc);
      u(all,all,all,eigc) *= eigSign/psiScaleFactor;

      if( !includePressure )
      {
        // Solve for the pressure if it is not computed when computing psi
        getPressureFromDisplacement( uv, p, bc, orderOfAccuracy,mu );
      }


      for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
      {
        MappedGrid & mg = cg[grid];
        getIndex(mg.dimension(),I1,I2,I3);
        if( includePressure )
        {
          real pSign = -1.; // what should this be ?   ************************************************ WHY ???

          p[grid] = (pSign*scaleFactor)*u(I1,I2,I3,pm);  // pressure computed with psi
        }

        uv[grid](I1,I2,I3,pc) = p[grid](I1,I2,I3);

        uv[grid](I1,I2,I3,psic) = u(I1,I2,I3,psim);  // psi : chosen eigenvector 
      }



      if( nameOfShowFile != "" )
      {
        // -- save a show file ---
        Ogshow show( nameOfShowFile );                               // create a show file
        show.saveGeneralComment("Results from genEigs");    // save a general comment in the show file

        ListOfShowFileParameters showFileParams;
        showFileParams.push_back(ShowFileParameter("u1Component",u1c));
        showFileParams.push_back(ShowFileParameter("u2Component",u2c));
        show.saveGeneralParameters(showFileParams);

        show.startFrame();                                             // start a new frame
        aString buff;
        show.saveComment(0,sPrintF(buff,"%s: order=%d, nx=%d, ny=%d",(const char*)problem,orderOfAccuracy,nx,ny));  
        // show.saveComment(1,sPrintF(buffer,"  t=%e ",t));               // comment 1 (shown on plot)
        show.saveSolution( uv );                                        // save the current grid function
        show.endFrame(); 
        show.close();   
        printF("Wrote show file=[%s]\n",(const char*)nameOfShowFile);
      }   


      // ---- check the residual ----
      realCompositeGridFunction res(cg,all,all,all,2);
      res.setName("u1res",0);
      res.setName("u2res",1);
      res = 0.;


      Real resMax; 
      for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
      {
        MappedGrid & mg = cg[grid];
        const IntegerArray & gid = mg.gridIndexRange();
        realMappedGridFunction & uvg = uv[grid];
        realMappedGridFunction & pg = p[grid];

        // int extra=-1;
        // getIndex(mg.gridIndexRange(),I1,I2,I3,extra);
        // ---- Fill equation for psi points ----
        //   bc = displacement : skip boundary for psi
        //      = traction     : include boundary
        getIndex(gid,I1,I2,I3);
        for( int axis=0; axis<numberOfDimensions; axis++ )
        {
          int ia = bc(0,axis)==displacement ? gid(0,axis)+1 : gid(0,axis); 
          int ib = bc(1,axis)==displacement ? gid(1,axis)-1 : gid(1,axis); 
          Iv[axis] = Range(ia,ib); 
        }          

        OV_GET_SERIAL_ARRAY(real,res[grid],resLocal);

        resLocal(I1,I2,I3,0) = mu*( uvg.xx(I1,I2,I3,0)(I1,I2,I3,0) + uvg.yy(I1,I2,I3,0)(I1,I2,I3,0) ) 
                                    - pg.x(I1,I2,I3,0)(I1,I2,I3,0) + lambda*uvg(I1,I2,I3,0);
        resMax = max(fabs(resLocal(I1,I2,I3,0)));
        printF("grid=%d: lambda=%9.3e, max-residual in mu*Delta(u1) -p.x + lambda*u1  =%8.2e\n",grid,lambda,resMax);

        resLocal(I1,I2,I3,1) = mu*( uvg.xx(I1,I2,I3,1)(I1,I2,I3,1) + uvg.yy(I1,I2,I3,1)(I1,I2,I3,1) ) 
                                    - pg.y(I1,I2,I3,0)(I1,I2,I3,0) + lambda*uvg(I1,I2,I3,1);
        resMax = max(fabs(resLocal(I1,I2,I3,1)));
        printF("grid=%d: lambda=%9.3e, max-residual in mu*Delta(u2) -p.y + lambda*u2  =%8.2e\n",grid,lambda,resMax);  


        ForBoundary(side,axis)
        {
          if( bc(side,axis)==traction )
          {
            int extra=-1; // skip ends
            getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3,extra);
            getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,1,extra);

            resLocal(Ig1,Ig2,Ig3,0) = uvg.x(Ib1,Ib2,Ib3,u1c)(Ib1,Ib2,Ib3,u1c) + uvg.y(Ib1,Ib2,Ib3,u2c)(Ib1,Ib2,Ib3,u2c);
            resMax = max(fabs(resLocal(Ig1,Ig2,Ig3,0)));
            printF("grid=%d: side=%d axis=%d residual(u1.x+u2.y) =%9.3e (saved in ghost)\n",grid,side,axis,resMax);            

            resLocal(Ig1,Ig2,Ig3,1) = uvg.x(Ib1,Ib2,Ib3,u2c)(Ib1,Ib2,Ib3,u2c) + uvg.y(Ib1,Ib2,Ib3,u1c)(Ib1,Ib2,Ib3,u1c);
            resMax = max(fabs(resLocal(Ig1,Ig2,Ig3,1)));
            printF("grid=%d: side=%d axis=%d residual(u2.x+u1.y) =%9.3e (saved in ghost)\n",grid,side,axis,resMax); 

          }
        }      

      }     
      Real resL2 = max( l2Norm(res,0), l2Norm(res,1) );
      printF(" L2-norm residual =%8.2e\n",resL2);

      // res.display("res");

      gi.erase();      

      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,false);      
      psp.set(GI_TOP_LABEL,sPrintF("Residual"));  // set title
      PlotIt::contour(gi, res,psp );
      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,true); 
      gi.erase();      

      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,false);      
      psp.set(GI_TOP_LABEL,sPrintF("Displacement and pressure"));  // set title
      PlotIt::contour(gi, uv,psp );
      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,true);  


          

    }  
    // else if( answer=="movie" )
    // {
    //   // --- plot a movie of the eye motion ---

    //   // fix the plot bounds as the eye moves 
    //   RealArray xBound(2,3);
    //   xBound(0,0)=-1.2; xBound(1,0)= 1.2;
    //   xBound(0,1)=-1.2; xBound(1,1)= 1.2;
    //   xBound(0,2)=-1.;  xBound(1,2)= 1.;

    //   real dt=.005*Pi, tFinal=10*Pi;
    //   int nStep=int( tFinal/dt + .5 );
    //   dt = tFinal/(nStep);

    //   real yMax=-1.e10; // keep track of the largest y value of the eye-lid 

    //   RealArray x;
    //   for( int step=0; step<nStep; step++ )
    //   {
    //     real t=step*dt;
        
    //     eyeCurves.getEyeCurve( x,t,numPoints );

    //     Range R = x.dimension(0);
    //     real yTop = max(x(R,1));
    //     if( yTop>yMax )
    //     {
    //       yMax=yTop;
    //     }
    //     else if( yTop>yMax*(.99999) )
    //     {
    //       printF("Eye reaches yMax=%9.3e at t=%9.3e t/(2*pi)=%9.3e\n",yMax,t,t/twoPi);
    //     }
        
    //     gi.erase();
    //     psp.set(GI_TOP_LABEL,sPrintF(buff,"genEigs: t=%9.2e, yMax=%8.2e",t,yMax));
    //     plotCurve( x, gi,psp );
    //     gi.setGlobalBound(xBound); // set plot bounds         

    //     gi.redraw(true);
    //   }

    // }

    // else if( answer=="save file" )
    // {
    //   aString fileName = "eyeCurveDataPoints.dat";
    //   eyeCurves.saveEyeCurve( time, numPoints, fileName );
    //   printF("Eye coordinates written to file=[%s]\n",(const char*)fileName);
    // }
    
    else
    {
      printF("Unknown response=[%s]\n",(const char*)answer);
    }
  }
  

  gi.unAppendTheDefaultPrompt();
  gi.popGUI(); // restore the previous GUI


  int ierr = SlepcFinalize();

  Overture::finish();  

  return 0;
}

