// ==================================================================================================
// Solve a generalized eigenvalue problem with SLEPc
//            A x = k B x
// 
// Started from SLEPc examples:
//      src/eps/examples/tutorials/ex2.c  : Laplace
//      src/eps/examples/tutorials/ex7.c  : generalized eig problem, read matrices from files
// ==================================================================================================






static char help[] = "Compute some  eigenvalues\n";

#include <slepceps.h>

#include "Overture.h"
#include "display.h"
#include "PlotStuff.h"  
#include "SquareMapping.h" 
#include "Ogshow.h"

#include "CompositeGridOperators.h"
#include "SparseRep.h" 
#include "Oges.h"
#include "ParallelUtility.h"
#include "gridFunctionNorms.h"

#define FOR_3D(i1,i2,i3,I1,I2,I3) \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(int i3=I3Base; i3<=I3Bound; i3++) \
for(int i2=I2Base; i2<=I2Bound; i2++) \
for(int i1=I1Base; i1<=I1Bound; i1++)  

#define FOR_3(i1,i2,i3,I1,I2,I3) \
I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(int i3=I3Base; i3<=I3Bound; i3++) \
for(int i2=I2Base; i2<=I2Bound; i2++) \
for(int i1=I1Base; i1<=I1Bound; i1++)  

#define ForBoundary(side,axis)   for( int axis=0; axis<numberOfDimensions; axis++ ) \
                                 for( int side=0; side<=1; side++ )  

// ============================================================================
// Compute the global matrix index ig from the grid-function index (i1,i2,i3)
// ===========================================================================
#beginMacro getGlobalIndex(i1,i2,i3,ig)
  ig = (i1)-n1a + nd1a*( (i2)-n2a );
#endMacro

// =================================================================================
// Compute the local grid-function index (i1,i2,i3) from the global matrix index ig
// ================================================================================
#beginMacro getLocalIndex( ig,i1,i2,i3 )
   i3 = 0;
   i2 = n2a + ig/nd1a;
   i1 = ig + n1a - nd1a*( (i2)-n2a );
#endMacro


// ==================================================================================
// Fill in the PETSc matrices A and B 
//          minus-Laplacian 
// ==================================================================================
int
fillMatrixLaplacian( int orderOfAccuracy, MappedGrid & mg, Mat & A, Mat & B, int numGhost, bool useNew, Real tol, int eigOption )
{
  PetscBool flag;
  int Istart,Iend,ierr;

  const int numberOfDimensions = mg.numberOfDimensions();

  const bool isRectangular = mg.isRectangular();
  real dx[3]={1.,1.,1.};
  if( isRectangular )
    mg.getDeltaX(dx);

  assert( isRectangular );

  const IntegerArray & gid = mg.gridIndexRange();

  // No boundary points: 
  int n = gid(1,0)-gid(0,0)+1 - 2;
  int m = gid(1,1)-gid(0,1)+1 - 2;

  const int nd1a = gid(1,0)-gid(0,0)+1 + 2*numGhost;
  const int nd2a = gid(1,1)-gid(0,1)+1 + 2*numGhost;

  const int n1a = gid(0,0)-numGhost;
  const int n2a = gid(0,1)-numGhost;

  const int n1b = gid(1,0)+numGhost;
  const int n2b = gid(1,1)+numGhost;


  // int orderOfAccuracy=2;
  const int extrapOrder = orderOfAccuracy+1;

  const Real extraplapCoeff3[] = {1.,-3.,3.,-1.};
  const Real extraplapCoeff4[] = {1.,-4.,6.,-4.,1.};
  const Real extraplapCoeff5[] = {1.,-5.,10.,-10.,5.,-1.};
  const Real extraplapCoeff6[] = {1.,-6.,15.,-20.,15.,-6.,1.};
  const Real extraplapCoeff7[] = {1.,-7.,21.,-35.,35.,-21.,7.,-1.};
  const Real extraplapCoeff8[] = {1.,-8.,28.,-56.,70.,-56.,28.,-8.,1.};
  const Real extraplapCoeff9[] = {1.,-9.,36.,-84.,126.,-126.,84.,-36.,9.,-1.};
  const Real *extraplapCoeff;
  if( extrapOrder==3 )
    extraplapCoeff = extraplapCoeff3;
  else if( extrapOrder==4 )
    extraplapCoeff = extraplapCoeff4;
  else if( extrapOrder==5 )
    extraplapCoeff = extraplapCoeff5;
  else if( extrapOrder==6 )
    extraplapCoeff = extraplapCoeff6;
  else if( extrapOrder==7 )
    extraplapCoeff = extraplapCoeff7;    
  else if( extrapOrder==8 )
    extraplapCoeff = extraplapCoeff8;     
  else if( extrapOrder==9 )
    extraplapCoeff = extraplapCoeff9;               
  else
   {
    printF("fillMatrixLaplacian:: unexpected extrapOrder=%d\n",extrapOrder);
    OV_ABORT("ERROR");
   }

  int i1,i2,i3;

  // int N = n*m;
  int N = nd1a*nd2a;

  // ----- MATRIX A -----

  Real dx2i = 1./(dx[0]*dx[0]);
  Real dy2i = 1./(dx[1]*dx[1]);
  Real diag = 2.*dx2i + 2.*dy2i; 

  int hw = orderOfAccuracy/2; // stencil half with
  Range S(-hw,hw); // stencil
  RealArray lapCoeff(S,S);
  lapCoeff=0.;
  if( orderOfAccuracy==2 )
  {
    // ----  -Delta : order=2 ----
    lapCoeff(0,0)  =  2./SQR(dx[0]) + 2./SQR(dx[1]);

    lapCoeff(-1,0) = -1./SQR(dx[0]);
    lapCoeff(+1,0) = -1./SQR(dx[0]);

    lapCoeff(0,-1) = -1./SQR(dx[1]);
    lapCoeff(0,+1) = -1./SQR(dx[1]);    
  }
  else if( orderOfAccuracy==4 )
  {
    // ----  -Delta : order=4 ----
    lapCoeff(0,0)  =  30./(12.*SQR(dx[0])) + 30./(12.*SQR(dx[1]));

    lapCoeff(-2,0) =   1./(12.*SQR(dx[0]));
    lapCoeff(-1,0) = -16./(12.*SQR(dx[0]));
    lapCoeff(+1,0) = -16./(12.*SQR(dx[0]));
    lapCoeff(+2,0) =   1./(12.*SQR(dx[0]));

    lapCoeff(0,-2) =   1./(12.*SQR(dx[1]));
    lapCoeff(0,-1) = -16./(12.*SQR(dx[1]));
    lapCoeff(0,+1) = -16./(12.*SQR(dx[1]));   
    lapCoeff(0,+2) =   1./(12.*SQR(dx[1]));   

  }
  else if( orderOfAccuracy==6 )
  {
    // ----  -Delta : order=6 ----
    lapCoeff(0,0)  =  490./(180.*SQR(dx[0])) + 490./(180.*SQR(dx[1]));

    lapCoeff(-3,0) =   -2./(180.*SQR(dx[0]));
    lapCoeff(-2,0) =   27./(180.*SQR(dx[0]));
    lapCoeff(-1,0) = -270./(180.*SQR(dx[0]));
    lapCoeff(+1,0) = -270./(180.*SQR(dx[0]));
    lapCoeff(+2,0) =   27./(180.*SQR(dx[0]));
    lapCoeff(+3,0) =   -2./(180.*SQR(dx[0]));

    lapCoeff(0,-3) =   -2./(180.*SQR(dx[1]));
    lapCoeff(0,-2) =   27./(180.*SQR(dx[1]));
    lapCoeff(0,-1) = -270./(180.*SQR(dx[1]));
    lapCoeff(0,+1) = -270./(180.*SQR(dx[1]));   
    lapCoeff(0,+2) =   27./(180.*SQR(dx[1]));   
    lapCoeff(0,+3) =   -2./(180.*SQR(dx[1]));   

  }  
  else if( orderOfAccuracy==8 )
  {
    // ----  -Delta : order=8 ----
    lapCoeff(0,0)  =  14350./(5040.*SQR(dx[0])) + 14350./(5040.*SQR(dx[1]));

    lapCoeff(-4,0) =     9./(5040.*SQR(dx[0]));
    lapCoeff(-3,0) =  -128./(5040.*SQR(dx[0]));
    lapCoeff(-2,0) =  1008./(5040.*SQR(dx[0]));
    lapCoeff(-1,0) = -8064./(5040.*SQR(dx[0]));
    lapCoeff(+1,0) = -8064./(5040.*SQR(dx[0]));
    lapCoeff(+2,0) =  1008./(5040.*SQR(dx[0]));
    lapCoeff(+3,0) =  -128./(5040.*SQR(dx[0]));
    lapCoeff(+4,0) =     9./(5040.*SQR(dx[0]));

    lapCoeff(0,-4) =     9./(5040.*SQR(dx[1]));
    lapCoeff(0,-3) =  -128./(5040.*SQR(dx[1]));
    lapCoeff(0,-2) =  1008./(5040.*SQR(dx[1]));
    lapCoeff(0,-1) = -8064./(5040.*SQR(dx[1]));
    lapCoeff(0,+1) = -8064./(5040.*SQR(dx[1]));   
    lapCoeff(0,+2) =  1008./(5040.*SQR(dx[1]));   
    lapCoeff(0,+3) =  -128./(5040.*SQR(dx[1]));   
    lapCoeff(0,+4) =     9./(5040.*SQR(dx[1]));   

  }    
  else
  {
    OV_ABORT("finish me - orderOfAccuracy");
  }

  ierr = MatCreate(PETSC_COMM_WORLD,&A);CHKERRQ(ierr);
  ierr = MatSetSizes(A,PETSC_DECIDE,PETSC_DECIDE,N,N);CHKERRQ(ierr);
  ierr = MatSetFromOptions(A);CHKERRQ(ierr);
  ierr = MatSetUp(A);CHKERRQ(ierr);

  ierr = MatGetOwnershipRange(A,&Istart,&Iend);CHKERRQ(ierr);



  Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
  Index Ibv[3], &Ib1=Ibv[0], &Ib2=Ibv[1], &Ib3=Ibv[2];
  Index Igv[3], &Ig1=Igv[0], &Ig2=Igv[1], &Ig3=Igv[2];
  int isv[3], &is1=isv[0], &is2=isv[1], &is3=isv[2];

  // ---- get interior points ----
  int extra=-1;
  getIndex(gid,I1,I2,I3,extra,extra,0);
  int ig0,ig;   


  // ---- interior points ----
  FOR_3D(i1,i2,i3,I1,I2,I3) 
  {
     getGlobalIndex( i1,i2,i3, ig0 );

     // printF("Interior: ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);

     // --- loop over stencil ---
     for( int iw2=-hw; iw2<=hw; iw2++ )
     {
       for( int iw1=-hw; iw1<=hw; iw1++ )
       {
         if( lapCoeff(iw1,iw2) != 0. )
         {
            getGlobalIndex( i1+iw1,i2+iw2,i3, ig );
            ierr = MatSetValue(A,ig0,ig,lapCoeff(iw1,iw2),INSERT_VALUES);CHKERRQ(ierr); 
          }
       }
     }
  }
    
  // --- fill in boundary points (constraints) ----
  ForBoundary(side,axis)
  {
    getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
    FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
    {
      getGlobalIndex( i1,i2,i3, ig0 );
      // printF("Boundary: ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);
      ierr = MatSetValue(A,ig0,ig0, 1.,INSERT_VALUES);CHKERRQ(ierr);  
    }          
  } 

  // --- fill in ghost points (constraints) ----
  ForBoundary(side,axis)
  {
    is1=is2=is3=0;
    isv[axis]=1-2*side;   // +1 on left and -1 on right 
    getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
    FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
    {
      for( int ghost=1; ghost<=numGhost; ghost++ )
      {
        int j1 = i1 -is1*ghost, j2 = i2 -is2*ghost,  j3 = i3;  // ghost point
        getGlobalIndex( j1,j2,j3, ig0 );
        // printF("Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);
        for( int k=0; k<=extrapOrder; k++ )
        {
          getGlobalIndex( j1+is1*k,j2+is2*k,j3, ig);
          ierr = MatSetValue(A,ig0,ig,extraplapCoeff[k],INSERT_VALUES);CHKERRQ(ierr);  
        }
      }
    }          
  }
  // --- fill corners ----
  for( int side2=0; side2<=1; side2++ ) 
  {
    for( int side1=0; side1<=1; side1++ ) 
    {
      is1=1-2*side1; is2=1-2*side2; is3=0;
      i1 = gid(side1,0); i2=gid(side2,1); i3=0; // corner point 
      for( int ghost2=1; ghost2<=numGhost; ghost2++ )
      {
        for( int ghost1=1; ghost1<=numGhost; ghost1++ )
        {
          int j1 = i1 -is1*ghost1, j2 = i2 -is2*ghost2, j3 = i3;  // ghost point
          getGlobalIndex( j1,j2,j3, ig0 );
          // printF("Corner Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);
          for( int k=0; k<=extrapOrder; k++ )
          {
            getGlobalIndex( j1+is1*k,j2+is2*k,j3, ig);
            ierr = MatSetValue(A,ig0,ig,extraplapCoeff[k],INSERT_VALUES);CHKERRQ(ierr);  
          }            
        }
      }
    }
  }

  ierr = MatAssemblyBegin(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  ierr = MatAssemblyEnd(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);



  // ----- MATRIX B = I -----

  ierr = MatCreate(PETSC_COMM_WORLD,&B);CHKERRQ(ierr);
  ierr = MatSetSizes(B,PETSC_DECIDE,PETSC_DECIDE,N,N);CHKERRQ(ierr);
  ierr = MatSetFromOptions(B);CHKERRQ(ierr);
  ierr = MatSetUp(B);CHKERRQ(ierr);

  ierr = MatGetOwnershipRange(B,&Istart,&Iend);CHKERRQ(ierr);
  if( !useNew )
  {
    for( int II=Istart; II<Iend; II++) 
    {
      int i = II/n; 
      int j = II-i*n;
      // if (i>0) { ierr = MatSetValue(B,II,II-n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
      // if (i<m-1) { ierr = MatSetValue(B,II,II+n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
      // if (j>0) { ierr = MatSetValue(B,II,II-1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
      // if (j<n-1) { ierr = MatSetValue(B,II,II+1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
      ierr = MatSetValue(B,II,II,1.0,INSERT_VALUES);CHKERRQ(ierr);
    }
  }
  else
  {
    // --- B(i,j) =1 : interior points ----
    getIndex(gid,I1,I2,I3,extra,extra,0);
    FOR_3D(i1,i2,i3,I1,I2,I3) 
    {
      getGlobalIndex( i1,i2,i3, ig0 );
      // printF("B ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);
      ierr = MatSetValue(B,ig0,ig0, 1.,INSERT_VALUES);CHKERRQ(ierr);      
    }
    if( true )
    {      
      // --- fill in boundary points (constraints) ----

      // FILL in a small value instead of zero for eigOption=0, since SLEPc wants B to be invertible

      const real smallValue = eigOption==0 ? tol/( SQR(dx[0]) ) : 0.; // 1.e-8; 

      ForBoundary(side,axis)
      {
        getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
        FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
        {
          getGlobalIndex( i1,i2,i3, ig0 );
          // printF("Boundary B: ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);
          ierr = MatSetValue(B,ig0,ig0, smallValue,INSERT_VALUES);CHKERRQ(ierr);  
        }          
      } 

      // --- fill in ghost points (constraints) ----
      ForBoundary(side,axis)
      {
        is1=is2=is3=0;
        isv[axis]=1-2*side;   // +1 on left and -1 on right 
        getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
        FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
        {
          for( int ghost=1; ghost<=numGhost; ghost++ )
          {
            int j1 = i1 -is1*ghost, j2 = i2 -is2*ghost,  j3 = i3;  // ghost point
            getGlobalIndex( j1,j2,j3, ig0 );
            // printF("B Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);
            ierr = MatSetValue(B,ig0,ig0, smallValue,INSERT_VALUES);CHKERRQ(ierr);             
          }
        }          
      }  

      // --- fill corners ----
      for( int side2=0; side2<=1; side2++ ) 
      {
        for( int side1=0; side1<=1; side1++ ) 
        {
          is1=1-2*side1; is2=1-2*side2; is3=0;
          i1 = gid(side1,0); i2=gid(side2,1); i3=0; // corner point 
          for( int ghost2=1; ghost2<=numGhost; ghost2++ )
          {
            for( int ghost1=1; ghost1<=numGhost; ghost1++ )
            {
              int j1 = i1 -is1*ghost1, j2 = i2 -is2*ghost2, j3 = i3;  // ghost point
              getGlobalIndex( j1,j2,j3, ig0 );
              // printF("B Corner Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);

              ierr = MatSetValue(B,ig0,ig0, smallValue,INSERT_VALUES);CHKERRQ(ierr);                  
            }
          }
        }
      }

    }   
  }

  ierr = MatAssemblyBegin(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  ierr = MatAssemblyEnd(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);

  return 0;
}


// ==================================================================================
// Fill in the PETSc matrices A and B 
//          Incompressible elasticity 
//
//  Solve for the stream-function
//
//      Delta^2( u ) = - lambda* Delta(u)
//      BC: u=0, u.n = 0 
// ==================================================================================
int
fillMatrixIncompressibleElasticity( const int numberOfComponents, int orderOfAccuracy, MappedGrid & mg, Mat & A, Mat & B, 
                                    int numGhost, bool useNew, Real tol, int eigOption )
{
  PetscBool flag;
  int Istart,Iend,ierr;

  const int numberOfDimensions = mg.numberOfDimensions();

  const bool isRectangular = mg.isRectangular();
  real dx[3]={1.,1.,1.};
  if( isRectangular )
    mg.getDeltaX(dx);

  assert( isRectangular );

  const IntegerArray & gid = mg.gridIndexRange();

  // No boundary points: 
  int n = gid(1,0)-gid(0,0)+1 - 2;
  int m = gid(1,1)-gid(0,1)+1 - 2;

  const int nd1a = gid(1,0)-gid(0,0)+1 + 2*numGhost;
  const int nd2a = gid(1,1)-gid(0,1)+1 + 2*numGhost;

  const int n1a = gid(0,0)-numGhost;
  const int n2a = gid(0,1)-numGhost;

  const int n1b = gid(1,0)+numGhost;
  const int n2b = gid(1,1)+numGhost;


  // int orderOfAccuracy=2;
  const int extrapOrder = orderOfAccuracy+1;  // what should this be?

  const Real extraplapCoeff3[] = {1.,-3.,3.,-1.};
  const Real extraplapCoeff4[] = {1.,-4.,6.,-4.,1.};
  const Real extraplapCoeff5[] = {1.,-5.,10.,-10.,5.,-1.};
  const Real extraplapCoeff6[] = {1.,-6.,15.,-20.,15.,-6.,1.};
  const Real extraplapCoeff7[] = {1.,-7.,21.,-35.,35.,-21.,7.,-1.};
  const Real extraplapCoeff8[] = {1.,-8.,28.,-56.,70.,-56.,28.,-8.,1.};
  const Real extraplapCoeff9[] = {1.,-9.,36.,-84.,126.,-126.,84.,-36.,9.,-1.};
  const Real *extraplapCoeff;
  if( extrapOrder==3 )
    extraplapCoeff = extraplapCoeff3;
  else if( extrapOrder==4 )
    extraplapCoeff = extraplapCoeff4;
  else if( extrapOrder==5 )
    extraplapCoeff = extraplapCoeff5;
  else if( extrapOrder==6 )
    extraplapCoeff = extraplapCoeff6;
  else if( extrapOrder==7 )
    extraplapCoeff = extraplapCoeff7;    
  else if( extrapOrder==8 )
    extraplapCoeff = extraplapCoeff8;     
  else if( extrapOrder==9 )
    extraplapCoeff = extraplapCoeff9;               
  else
   {
    printF("fillMatrixLaplacian:: unexpected extrapOrder=%d\n",extrapOrder);
    OV_ABORT("ERROR");
   }

  int i1,i2,i3;

  // int N = n*m;
  int N = nd1a*nd2a*numberOfComponents;

  // ----- MATRIX A -----

  Real dx2i = 1./(dx[0]*dx[0]);
  Real dy2i = 1./(dx[1]*dx[1]);
  Real diag = 2.*dx2i + 2.*dy2i; 

  int hw = orderOfAccuracy/2; // stencil half with
  Range S(-hw,hw); // stencil
  RealArray lapCoeff(S,S);
  lapCoeff=0.;

  int hw2 = hw+1; // half-width stencil for bi-Harmonic 
  Range S2(-hw2,hw2); 
  RealArray biCoeff(S2,S2), xxxxCoeff(S2), yyyyCoeff(S2);
  biCoeff=0.; xxxxCoeff=0.; yyyyCoeff=0.;

  RealArray xCoeff(S), yCoeff(S), xxCoeff(S), yyCoeff(S), xxyyCoeff(S,S); 
  xCoeff=0.; yCoeff=0.; xxCoeff=0.; yyCoeff=0.; xxyyCoeff=0.;

  if( orderOfAccuracy==2 )
  {

    // --- Dx and Dy coefficients ---
    xCoeff(-1) = -1./(2.*dx[0]);
    xCoeff(+1) =  1./(2.*dx[0]);

    yCoeff(-1) = -1./(2.*dx[1]);
    yCoeff(+1) =  1./(2.*dx[1]);

    // ----  -Delta : order=2 ----
    lapCoeff(0,0)  =  2./SQR(dx[0]) + 2./SQR(dx[1]);

    lapCoeff(-1,0) = -1./SQR(dx[0]);
    lapCoeff(+1,0) = -1./SQR(dx[0]);

    lapCoeff(0,-1) = -1./SQR(dx[1]);
    lapCoeff(0,+1) = -1./SQR(dx[1]);   

    // ---- Bi-Harmonic coefficients ------
    //   Dxxxx + 2*Dxxyy + Dyyyy
    //  Dxxxx = [ 1 -4 6 -4 1 ]/( dx^4 )
    //          [ 1 -2  1]
    //  Dxxyy = [-2  4 -2]/ (dx^2 dy^2)
    //          [ 1 -2  1]
    const Real dx2 = pow(dx[0],2.);
    const Real dy2 = pow(dx[1],2.);
    const Real dx4 = pow(dx[0],4.);
    const Real dy4 = pow(dx[1],4.);
    biCoeff(0,0)  =  6./dx4 + 6./dy4 + 2.*4./(dx2*dy2); 

    biCoeff(-2,0) =  1./(dx4);
    biCoeff(-1,0) = -4./(dx4)  -2.*2./(dx2*dy2);
    biCoeff(+1,0) = -4./(dx4)  -2.*2./(dx2*dy2);
    biCoeff(+2,0) =  1./(dx4);

    biCoeff(0,-2) =  1./(dy4);
    biCoeff(0,-1) = -4./(dy4)  -2.*2./(dx2*dy2);
    biCoeff(0,+1) = -4./(dy4)  -2.*2./(dx2*dy2);   
    biCoeff(0,+2) =  1./(dy4);   

    biCoeff(-1,-1) = 2.*1./(dx2*dy2);
    biCoeff(+1,-1) = 2.*1./(dx2*dy2);        
    biCoeff(-1,+1) = 2.*1./(dx2*dy2);
    biCoeff(+1,+1) = 2.*1./(dx2*dy2);        
  }
  else if( orderOfAccuracy==4 )
  {
    // ---- order=4 ----

    // --- Dx and Dy coefficients ---
    xCoeff(-2) =  1./(12.*dx[0]);
    xCoeff(-1) = -8./(12.*dx[0]);
    xCoeff( 0) =  0./(12.*dx[0]);
    xCoeff(+1) =  8./(12.*dx[0]);
    xCoeff(+2) = -1./(12.*dx[0]);

    yCoeff(-2) =  1./(12.*dx[1]);
    yCoeff(-1) = -8./(12.*dx[1]);
    yCoeff( 0) =  0./(12.*dx[1]);
    yCoeff(+1) =  8./(12.*dx[1]);
    yCoeff(+2) = -1./(12.*dx[1]);    


    xxCoeff(-2) =  -1./(12.*SQR(dx[0]));
    xxCoeff(-1) =  16./(12.*SQR(dx[0]));
    xxCoeff( 0) = -30./(12.*SQR(dx[0]));
    xxCoeff(+1) =  16./(12.*SQR(dx[0]));
    xxCoeff(+2) =  -1./(12.*SQR(dx[0]));   

    yyCoeff(-2) =  -1./(12.*SQR(dx[1]));
    yyCoeff(-1) =  16./(12.*SQR(dx[1]));
    yyCoeff( 0) = -30./(12.*SQR(dx[1]));
    yyCoeff(+1) =  16./(12.*SQR(dx[1]));
    yyCoeff(+2) =  -1./(12.*SQR(dx[1]));  

    for( int iw2=-hw; iw2<=hw; iw2++ )
    {
      for( int iw1=-hw; iw1<=hw; iw1++ )
      {
        xxyyCoeff(iw1,iw2) = xxCoeff(iw1)*yyCoeff(iw2); 
      }
    }

    xxxxCoeff(-3) =  -1./(6.*pow(dx[0],4.));
    xxxxCoeff(-2) =  12./(6.*pow(dx[0],4.));
    xxxxCoeff(-1) = -39./(6.*pow(dx[0],4.));
    xxxxCoeff( 0) =  56./(6.*pow(dx[0],4.));
    xxxxCoeff(+1) = -39./(6.*pow(dx[0],4.));
    xxxxCoeff(+2) =  12./(6.*pow(dx[0],4.));              
    xxxxCoeff(+3) =  -1./(6.*pow(dx[0],4.));  

    yyyyCoeff(-3) =  -1./(6.*pow(dx[1],4.));
    yyyyCoeff(-2) =  12./(6.*pow(dx[1],4.));
    yyyyCoeff(-1) = -39./(6.*pow(dx[1],4.));
    yyyyCoeff( 0) =  56./(6.*pow(dx[1],4.));
    yyyyCoeff(+1) = -39./(6.*pow(dx[1],4.));
    yyyyCoeff(+2) =  12./(6.*pow(dx[1],4.));              
    yyyyCoeff(+3) =  -1./(6.*pow(dx[1],4.));                  


    // -- -Laplacian --
    lapCoeff(0,0)  =  30./(12.*SQR(dx[0])) + 30./(12.*SQR(dx[1]));

    lapCoeff(-2,0) =   1./(12.*SQR(dx[0]));
    lapCoeff(-1,0) = -16./(12.*SQR(dx[0]));
    lapCoeff(+1,0) = -16./(12.*SQR(dx[0]));
    lapCoeff(+2,0) =   1./(12.*SQR(dx[0]));

    lapCoeff(0,-2) =   1./(12.*SQR(dx[1]));
    lapCoeff(0,-1) = -16./(12.*SQR(dx[1]));
    lapCoeff(0,+1) = -16./(12.*SQR(dx[1]));   
    lapCoeff(0,+2) =   1./(12.*SQR(dx[1])); 

    // Delta^2 = Dxxxx + Dyyyy + 2*Dxxyy
    for( int iw=-hw2; iw<=hw2; iw++ ) 
    {
      biCoeff(iw,0) += xxxxCoeff(iw);
      biCoeff(0,iw) += yyyyCoeff(iw);
    }

    for( int iw2=-hw; iw2<=hw; iw2++ )
    {
      for( int iw1=-hw; iw1<=hw; iw1++ )
      {
        biCoeff(iw1,iw2) += 2.*xxyyCoeff(iw1,iw2);
      }
    }


  }
  else if( orderOfAccuracy==6 )
  {
    // ----  -Delta : order=6 ----
    lapCoeff(0,0)  =  490./(180.*SQR(dx[0])) + 490./(180.*SQR(dx[1]));

    lapCoeff(-3,0) =   -2./(180.*SQR(dx[0]));
    lapCoeff(-2,0) =   27./(180.*SQR(dx[0]));
    lapCoeff(-1,0) = -270./(180.*SQR(dx[0]));
    lapCoeff(+1,0) = -270./(180.*SQR(dx[0]));
    lapCoeff(+2,0) =   27./(180.*SQR(dx[0]));
    lapCoeff(+3,0) =   -2./(180.*SQR(dx[0]));

    lapCoeff(0,-3) =   -2./(180.*SQR(dx[1]));
    lapCoeff(0,-2) =   27./(180.*SQR(dx[1]));
    lapCoeff(0,-1) = -270./(180.*SQR(dx[1]));
    lapCoeff(0,+1) = -270./(180.*SQR(dx[1]));   
    lapCoeff(0,+2) =   27./(180.*SQR(dx[1]));   
    lapCoeff(0,+3) =   -2./(180.*SQR(dx[1]));   

    OV_ABORT("biH - finish me");

  }  
  else if( orderOfAccuracy==8 )
  {
    // ----  -Delta : order=8 ----
    lapCoeff(0,0)  =  14350./(5040.*SQR(dx[0])) + 14350./(5040.*SQR(dx[1]));

    lapCoeff(-4,0) =     9./(5040.*SQR(dx[0]));
    lapCoeff(-3,0) =  -128./(5040.*SQR(dx[0]));
    lapCoeff(-2,0) =  1008./(5040.*SQR(dx[0]));
    lapCoeff(-1,0) = -8064./(5040.*SQR(dx[0]));
    lapCoeff(+1,0) = -8064./(5040.*SQR(dx[0]));
    lapCoeff(+2,0) =  1008./(5040.*SQR(dx[0]));
    lapCoeff(+3,0) =  -128./(5040.*SQR(dx[0]));
    lapCoeff(+4,0) =     9./(5040.*SQR(dx[0]));

    lapCoeff(0,-4) =     9./(5040.*SQR(dx[1]));
    lapCoeff(0,-3) =  -128./(5040.*SQR(dx[1]));
    lapCoeff(0,-2) =  1008./(5040.*SQR(dx[1]));
    lapCoeff(0,-1) = -8064./(5040.*SQR(dx[1]));
    lapCoeff(0,+1) = -8064./(5040.*SQR(dx[1]));   
    lapCoeff(0,+2) =  1008./(5040.*SQR(dx[1]));   
    lapCoeff(0,+3) =  -128./(5040.*SQR(dx[1]));   
    lapCoeff(0,+4) =     9./(5040.*SQR(dx[1])); 

    OV_ABORT("biH - finish me");
  }    
  else
  {
    OV_ABORT("finish me - orderOfAccuracy");
  }

  ierr = MatCreate(PETSC_COMM_WORLD,&A);CHKERRQ(ierr);
  ierr = MatSetSizes(A,PETSC_DECIDE,PETSC_DECIDE,N,N);CHKERRQ(ierr);
  ierr = MatSetFromOptions(A);CHKERRQ(ierr);
  ierr = MatSetUp(A);CHKERRQ(ierr);

  ierr = MatGetOwnershipRange(A,&Istart,&Iend);CHKERRQ(ierr);

  Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
  Index Ibv[3], &Ib1=Ibv[0], &Ib2=Ibv[1], &Ib3=Ibv[2];
  Index Igv[3], &Ig1=Igv[0], &Ig2=Igv[1], &Ig3=Igv[2];
  int isv[3], &is1=isv[0], &is2=isv[1], &is3=isv[2];

  // ---- get interior points ----
  int extra=-1;
  getIndex(gid,I1,I2,I3,extra,extra,0);
  int ig0,ig;   



  // ---- interior points ----
  FOR_3D(i1,i2,i3,I1,I2,I3) 
  {
     getGlobalIndex( i1,i2,i3, ig0 );

     // printF("Interior: ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);

     // --- FILL BI-HARMONIC ----
     // --- loop over stencil ---
     for( int iw2=-hw2; iw2<=hw2; iw2++ )
     {
       for( int iw1=-hw2; iw1<=hw2; iw1++ )
       {
         if( biCoeff(iw1,iw2) != 0. )
         {
            getGlobalIndex( i1+iw1,i2+iw2,i3, ig );
            ierr = MatSetValue(A,ig0,ig, biCoeff(iw1,iw2),INSERT_VALUES);CHKERRQ(ierr); 
          }
       }
     }

  } 
    
  // --- fill in boundary points (constraints) ----
  ForBoundary(side,axis)
  {
    getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
    FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
    {
      getGlobalIndex( i1,i2,i3, ig0 );
      // printF("Boundary: ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);

      // --- Dirichlet BC :
      ierr = MatSetValue(A,ig0,ig0, 1.,INSERT_VALUES);CHKERRQ(ierr); 

    }          
  } 

  // --- fill in ghost points (constraints) ----

  ForBoundary(side,axis)
  {
    is1=is2=is3=0;
    isv[axis]=1-2*side;   // +1 on left and -1 on right 
    getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
    FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
    {

      // --- Neumann BC on first ghost line ---
      int ghost = 1;
      int j1 = i1 -is1*ghost, j2 = i2 -is2*ghost,  j3 = i3;  // ghost point

      getGlobalIndex( j1,j2,j3, ig0 );   // ghost point - put equation here 
      Real coeff=0.;
      for( int iw=-hw; iw<=hw; iw++ )
      {
         if( axis==0 )
         {
           getGlobalIndex( i1+iw,i2,i3, ig ); // centre stencil on the boundary (i1,i2,i3)
           coeff = xCoeff(iw);
         }
         else
         {
           getGlobalIndex( i1,i2+iw,i3, ig );   // centre stencil on the boundary 
           coeff = yCoeff(iw);
         }
         if( coeff !=0. )
         {
           ierr = MatSetValue(A,ig0,ig, coeff,INSERT_VALUES);CHKERRQ(ierr);  
         }

      }

      // -- extrapolate other ghost 
      for( int ghost=2; ghost<=numGhost; ghost++ )
      {
        int j1 = i1 -is1*ghost, j2 = i2 -is2*ghost,  j3 = i3;  // ghost point
        getGlobalIndex( j1,j2,j3, ig0 );
        // printF("Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);
        for( int k=0; k<=extrapOrder; k++ )
        {
          getGlobalIndex( j1+is1*k,j2+is2*k,j3, ig);
          ierr = MatSetValue(A,ig0,ig,extraplapCoeff[k],INSERT_VALUES);CHKERRQ(ierr);  
        }
      }
    }          
  }  

  // --- fill corners ----
  for( int side2=0; side2<=1; side2++ ) 
  {
    for( int side1=0; side1<=1; side1++ ) 
    {
      is1=1-2*side1; is2=1-2*side2; is3=0;
      i1 = gid(side1,0); i2=gid(side2,1); i3=0; // corner point 
      for( int ghost2=1; ghost2<=numGhost; ghost2++ )
      {
        for( int ghost1=1; ghost1<=numGhost; ghost1++ )
        {
          int j1 = i1 -is1*ghost1, j2 = i2 -is2*ghost2, j3 = i3;  // ghost point
          getGlobalIndex( j1,j2,j3, ig0 );
          // printF("Corner Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);
          for( int k=0; k<=extrapOrder; k++ )
          {
            getGlobalIndex( j1+is1*k,j2+is2*k,j3, ig);
            ierr = MatSetValue(A,ig0,ig,extraplapCoeff[k],INSERT_VALUES);CHKERRQ(ierr);  
          }            
        }
      }
    }
  }

  ierr = MatAssemblyBegin(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  ierr = MatAssemblyEnd(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);



  // ----- MATRIX B = Delta -----

  ierr = MatCreate(PETSC_COMM_WORLD,&B);CHKERRQ(ierr);
  ierr = MatSetSizes(B,PETSC_DECIDE,PETSC_DECIDE,N,N);CHKERRQ(ierr);
  ierr = MatSetFromOptions(B);CHKERRQ(ierr);
  ierr = MatSetUp(B);CHKERRQ(ierr);

  ierr = MatGetOwnershipRange(B,&Istart,&Iend);CHKERRQ(ierr);

  // --- B(i,j) = -Delta : interior points ----
  extra=-1; 
  getIndex(gid,I1,I2,I3,extra,extra,0);
  FOR_3(i1,i2,i3,I1,I2,I3) 
  {
    getGlobalIndex( i1,i2,i3, ig0 );
    // printF("B ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);
    // --- loop over stencil ---
    for( int iw2=-hw; iw2<=hw; iw2++ )
    {
      for( int iw1=-hw; iw1<=hw; iw1++ )
      {
        if( lapCoeff(iw1,iw2) != 0. )
        {
           getGlobalIndex( i1+iw1,i2+iw2,i3, ig );
           ierr = MatSetValue(B,ig0,ig, lapCoeff(iw1,iw2),INSERT_VALUES);CHKERRQ(ierr); 
         }
      }
    }        
  }

  // --- fill in boundary points (constraints) ----

  // FILL in a small value instead of zero
  const real smallValue = eigOption==0 ? tol/( SQR(dx[0]) ) : 0.; // 1.e-8; 

  ForBoundary(side,axis)
  {
    getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
    FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
    {
      getGlobalIndex( i1,i2,i3, ig0 );
      // printF("Boundary B: ig0=%d, i1=%d, i2=%d\n",ig0,i1,i2);
      ierr = MatSetValue(B,ig0,ig0, smallValue,INSERT_VALUES);CHKERRQ(ierr);  
    }          
  } 

  // --- fill in ghost points (constraints) ----
  ForBoundary(side,axis)
  {
    is1=is2=is3=0;
    isv[axis]=1-2*side;   // +1 on left and -1 on right 
    getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
    FOR_3D(i1,i2,i3,Ib1,Ib2,Ib3) 
    {
      for( int ghost=1; ghost<=numGhost; ghost++ )
      {
        int j1 = i1 -is1*ghost, j2 = i2 -is2*ghost,  j3 = i3;  // ghost point
        getGlobalIndex( j1,j2,j3, ig0 );
        // printF("B Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);
        ierr = MatSetValue(B,ig0,ig0, smallValue,INSERT_VALUES);CHKERRQ(ierr);             
      }
    }          
  }  

  // --- fill corners ----
  for( int side2=0; side2<=1; side2++ ) 
  {
    for( int side1=0; side1<=1; side1++ ) 
    {
      is1=1-2*side1; is2=1-2*side2; is3=0;
      i1 = gid(side1,0); i2=gid(side2,1); i3=0; // corner point 
      for( int ghost2=1; ghost2<=numGhost; ghost2++ )
      {
        for( int ghost1=1; ghost1<=numGhost; ghost1++ )
        {
          int j1 = i1 -is1*ghost1, j2 = i2 -is2*ghost2, j3 = i3;  // ghost point
          getGlobalIndex( j1,j2,j3, ig0 );
          // printF("B Corner Ghost: ig0=%d, j1=%d, j2=%d\n",ig0,j1,j2);

          ierr = MatSetValue(B,ig0,ig0, smallValue,INSERT_VALUES);CHKERRQ(ierr);                  
        }
      }
    }
  }

  ierr = MatAssemblyBegin(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  ierr = MatAssemblyEnd(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);

  return 0;
}

// ==================================================================================
// Compute the eigenvalues using SLEPc
// ==================================================================================
int
computeEigenvalues( const aString & problem, const int numberOfComponents,
                    int orderOfAccuracy, int numEigenValues, int numEigenVectors, 
                    RealArray & eig, realMappedGridFunction & u, Real tol, int eigOption )
{

  Mat            A,B;             /* matrices */
  EPS            eps;             /* eigenproblem solver context */
  EPSType        type;
  Vec            xr,xi,*Iv,*Cv;
  PetscInt       nev,maxit,i,its,lits,nconv,nini=0,ncon=0;
  char           filename[PETSC_MAX_PATH_LEN];
  PetscViewer    viewer;
  PetscBool      flg,evecs,ishermitian;
  PetscErrorCode ierr;

  // SlepcInitialize(&argc,&argv,(char*)0,help);


  PetscBool      flag;
  int j,N,m,n,Istart,Iend,II;

  // ierr = PetscOptionsGetInt(NULL,"-n",&n,NULL);CHKERRQ(ierr);
  // ierr = PetscOptionsGetInt(NULL,"-m",&m,&flag);CHKERRQ(ierr);
  // if (!flag) m=n;

  MappedGrid & mg = *u.getMappedGrid();
  const bool isRectangular = mg.isRectangular();
  real dx[3]={1.,1.,1.};
  if( isRectangular )
    mg.getDeltaX(dx);

  assert( isRectangular );

  const IntegerArray & gid = mg.gridIndexRange();
  n = gid(1,0)-gid(0,0)+1 - 2;
  m = gid(1,1)-gid(0,1)+1 - 2;

  // ----- Number of ghost points ----
  const int numGhost= orderOfAccuracy/2;


  const int nd1a = gid(1,0)-gid(0,0)+1 + 2*numGhost;
  const int nd2a = gid(1,1)-gid(0,1)+1 + 2*numGhost;
  const int n1a = gid(0,0)-numGhost;
  const int n2a = gid(0,1)-numGhost;
  const int n1b = gid(1,0)+numGhost;
  const int n2b = gid(1,1)+numGhost;  

  int i1,i2,i3;

  bool useNew=true;


  // N = n*m;
  N = nd1a*nd2a*numberOfComponents; // total number of grid points

  ierr = PetscPrintf(PETSC_COMM_WORLD,"\n Generalized Eigenavlue Problem Ax = k Bx, N=%D (%Dx%D grid)\n\n",N,n,m);CHKERRQ(ierr);



   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   //      Load the matrices that define the eigensystem, Ax=kBx
   //   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

//   ierr = PetscPrintf(PETSC_COMM_WORLD,"\nGeneralized eigenproblem stored in file.\n\n");CHKERRQ(ierr);
//   ierr = PetscOptionsGetString(NULL,"-f1",filename,PETSC_MAX_PATH_LEN,&flg);CHKERRQ(ierr);
//   if (!flg) SETERRQ(PETSC_COMM_WORLD,1,"Must indicate a file name for matrix A with the -f1 option");

// #if defined(PETSC_USE_COMPLEX)
//   ierr = PetscPrintf(PETSC_COMM_WORLD," Reading COMPLEX matrices from binary files...\n");CHKERRQ(ierr);
// #else
//   ierr = PetscPrintf(PETSC_COMM_WORLD," Reading REAL matrices from binary files...\n");CHKERRQ(ierr);
// #endif
//   ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_READ,&viewer);CHKERRQ(ierr);
//   ierr = MatCreate(PETSC_COMM_WORLD,&A);CHKERRQ(ierr);
//   ierr = MatSetFromOptions(A);CHKERRQ(ierr);
//   ierr = MatLoad(A,viewer);CHKERRQ(ierr);
//   ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);

//   ierr = PetscOptionsGetString(NULL,"-f2",filename,PETSC_MAX_PATH_LEN,&flg);CHKERRQ(ierr);
//   if (flg) {
//     ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_READ,&viewer);CHKERRQ(ierr);
//     ierr = MatCreate(PETSC_COMM_WORLD,&B);CHKERRQ(ierr);
//     ierr = MatSetFromOptions(B);CHKERRQ(ierr);
//     ierr = MatLoad(B,viewer);CHKERRQ(ierr);
//     ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
//   } else {
//     ierr = PetscPrintf(PETSC_COMM_WORLD," Matrix B was not provided, setting B=I\n\n");CHKERRQ(ierr);
//     B = NULL;
//   }


  // ---- Fill Matrix A and B for the minus Laplacian ----
  if( problem=="laplace" )
  {
    fillMatrixLaplacian( orderOfAccuracy, mg, A, B, numGhost, useNew, tol, eigOption );
  }
  else if( problem=="ile" )
  {
    fillMatrixIncompressibleElasticity( numberOfComponents, orderOfAccuracy, mg, A, B, numGhost, useNew, tol, eigOption );
  }
  else
  {
    OV_ABORT("ERROR: unknown problem");
  }

  // // ----- MATRIX A -----

  // ierr = MatCreate(PETSC_COMM_WORLD,&A);CHKERRQ(ierr);
  // ierr = MatSetSizes(A,PETSC_DECIDE,PETSC_DECIDE,N,N);CHKERRQ(ierr);
  // ierr = MatSetFromOptions(A);CHKERRQ(ierr);
  // ierr = MatSetUp(A);CHKERRQ(ierr);

  // ierr = MatGetOwnershipRange(A,&Istart,&Iend);CHKERRQ(ierr);

  // Real dx2i = 1./(dx[0]*dx[0]);
  // Real dy2i = 1./(dx[1]*dx[1]);
  // Real diag = 2.*dx2i + 2.*dy2i; 
  // for (II=Istart;II<Iend;II++) {
  //   i = II/n; j = II-i*n;
  //   if (i>0) {   ierr = MatSetValue(A,II,II-n,-dy2i,INSERT_VALUES);CHKERRQ(ierr); }
  //   if (i<m-1) { ierr = MatSetValue(A,II,II+n,-dy2i,INSERT_VALUES);CHKERRQ(ierr); }

  //   if (j>0) {   ierr = MatSetValue(A,II,II-1,-dx2i,INSERT_VALUES);CHKERRQ(ierr); }
  //   if (j<n-1) { ierr = MatSetValue(A,II,II+1,-dx2i,INSERT_VALUES);CHKERRQ(ierr); }

  //   ierr =              MatSetValue(A,II,II  , diag,INSERT_VALUES);CHKERRQ(ierr);

  //   // if (i>0) { ierr = MatSetValue(A,II,II-n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (i<m-1) { ierr = MatSetValue(A,II,II+n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (j>0) { ierr = MatSetValue(A,II,II-1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (j<n-1) { ierr = MatSetValue(A,II,II+1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // ierr = MatSetValue(A,II,II,4.0,INSERT_VALUES);CHKERRQ(ierr);

  // }

  // ierr = MatAssemblyBegin(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  // ierr = MatAssemblyEnd(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);



  // // ----- MATRIX B = I -----

  // ierr = MatCreate(PETSC_COMM_WORLD,&B);CHKERRQ(ierr);
  // ierr = MatSetSizes(B,PETSC_DECIDE,PETSC_DECIDE,N,N);CHKERRQ(ierr);
  // ierr = MatSetFromOptions(B);CHKERRQ(ierr);
  // ierr = MatSetUp(B);CHKERRQ(ierr);

  // ierr = MatGetOwnershipRange(B,&Istart,&Iend);CHKERRQ(ierr);
  // for (II=Istart;II<Iend;II++) {
  //   i = II/n; j = II-i*n;
  //   // if (i>0) { ierr = MatSetValue(B,II,II-n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (i<m-1) { ierr = MatSetValue(B,II,II+n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (j>0) { ierr = MatSetValue(B,II,II-1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (j<n-1) { ierr = MatSetValue(B,II,II+1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   ierr = MatSetValue(B,II,II,1.0,INSERT_VALUES);CHKERRQ(ierr);
  // }

  // ierr = MatAssemblyBegin(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  // ierr = MatAssemblyEnd(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);



  ierr = MatGetVecs(A,NULL,&xr);CHKERRQ(ierr);
  ierr = MatGetVecs(A,NULL,&xi);CHKERRQ(ierr);

  /*
     Read user constraints if available
  */
  ierr = PetscOptionsGetInt(NULL,"-nconstr",&ncon,&flg);CHKERRQ(ierr);
  if (flg) {
    if (ncon<=0) SETERRQ(PETSC_COMM_WORLD,1,"The number of constraints must be >0");
    ierr = PetscOptionsGetString(NULL,"-fconstr",filename,PETSC_MAX_PATH_LEN,&flg);CHKERRQ(ierr);
    if (!flg) SETERRQ(PETSC_COMM_WORLD,1,"Must specify the name of the file storing the constraints");
    ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_READ,&viewer);CHKERRQ(ierr);
    ierr = VecDuplicateVecs(xr,ncon,&Cv);CHKERRQ(ierr);
    for (i=0;i<ncon;i++) {
      ierr = VecLoad(Cv[i],viewer);CHKERRQ(ierr);
    }
    ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
  }

  /*
     Read initial guesses if available
  */
  ierr = PetscOptionsGetInt(NULL,"-ninitial",&nini,&flg);CHKERRQ(ierr);
  if (flg) {
    if (nini<=0) SETERRQ(PETSC_COMM_WORLD,1,"The number of initial vectors must be >0");
    ierr = PetscOptionsGetString(NULL,"-finitial",filename,PETSC_MAX_PATH_LEN,&flg);CHKERRQ(ierr);
    if (!flg) SETERRQ(PETSC_COMM_WORLD,1,"Must specify the name of the file containing the initial vectors");
    ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_READ,&viewer);CHKERRQ(ierr);
    ierr = VecDuplicateVecs(xr,nini,&Iv);CHKERRQ(ierr);
    for (i=0;i<nini;i++) {
      ierr = VecLoad(Iv[i],viewer);CHKERRQ(ierr);
    }
    ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                Create the eigensolver and set various options
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /*
     Create eigensolver context
  */
  ierr = EPSCreate(PETSC_COMM_WORLD,&eps);CHKERRQ(ierr);

  /*
     Set operators. In this case, it is a generalized eigenvalue problem
  */
  if( eigOption==0 )
  {
     // Solve A x = k B x
    ierr = EPSSetOperators(eps,A,B);CHKERRQ(ierr);
  }
  else
  {
     // Solve B x = k A x
    ierr = EPSSetOperators(eps,B,A);CHKERRQ(ierr);
  }

  /*
     If the user provided initial guesses or constraints, pass them here
  */
  ierr = EPSSetInitialSpace(eps,nini,Iv);CHKERRQ(ierr);
  ierr = EPSSetDeflationSpace(eps,ncon,Cv);CHKERRQ(ierr);

  // ---- choose eigenvalues to find ----
  if( eigOption==0 )
  {
    ierr = EPSSetWhichEigenpairs(eps,EPS_SMALLEST_MAGNITUDE); CHKERRQ(ierr);
  }
  else
  {
    ierr = EPSSetWhichEigenpairs(eps,EPS_LARGEST_MAGNITUDE); CHKERRQ(ierr);
  }

  PetscInt maxIt = 10000; 
  ierr = EPSSetTolerances(eps,tol,maxIt); CHKERRQ(ierr);

  /*
     Set solver parameters at runtime
  */
  ierr = EPSSetFromOptions(eps);CHKERRQ(ierr);

  PetscInt mpd = PETSC_DEFAULT; // numEigenVectors; // maximum projected dimension, decrease to save space
  printF("Setting numEigenValues=%d, numEigenVectors=%d,\n",numEigenValues,numEigenVectors);
  PetscInt ncv = PETSC_DEFAULT; // numEigenValues*2+1; // size of column space 
  ierr = EPSSetDimensions(eps,numEigenValues,ncv,mpd); CHKERRQ(ierr);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                      Solve the eigensystem
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  ierr = EPSSolve(eps);CHKERRQ(ierr);

  /*
     Optional: Get some information from the solver and display it
  */
  ierr = EPSGetIterationNumber(eps,&its);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD," Number of iterations of the method: %D\n",its);CHKERRQ(ierr);
  ierr = EPSGetOperationCounters(eps,NULL,NULL,&lits);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD," Number of linear iterations of the method: %D\n",lits);CHKERRQ(ierr);
  ierr = EPSGetType(eps,&type);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD," Solution method: %s\n\n",type);CHKERRQ(ierr);

  ierr = EPSGetDimensions(eps,&nev,NULL,NULL);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD," Number of requested eigenvalues: %D\n",nev);CHKERRQ(ierr);

  nev = numEigenValues;

  ierr = EPSGetTolerances(eps,&tol,&maxit);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD," Stopping condition: tol=%.4G, maxit=%D\n",tol,maxit);CHKERRQ(ierr);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                    Display solution and clean up
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  ierr = EPSPrintSolution(eps,NULL);CHKERRQ(ierr);
  /*
     Save eigenvectors, if requested
  */
  ierr = PetscOptionsGetString(NULL,"-evecs",filename,PETSC_MAX_PATH_LEN,&evecs);CHKERRQ(ierr);

  ierr = EPSGetConverged(eps,&nconv);CHKERRQ(ierr);
  if( nconv>0 && nev>0 ) 
  {
    // ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_WRITE,&viewer);CHKERRQ(ierr);
    // ierr = EPSIsHermitian(eps,&ishermitian);CHKERRQ(ierr);
    // for (i=0;i<nconv;i++) 
    eig.redim(2,numEigenVectors);

    for( int i=0; i<numEigenVectors; i++ ) 
    {

      PetscScalar kr, ki;
      ierr = EPSGetEigenpair(eps,i,&kr,&ki,xr,xi); CHKERRQ(ierr);
      if( eigOption==0 )
      {
        eig(0,i) = kr;
        eig(1,i) = ki;
      }
      else
      {
        // 1/z = zBar/ |z|^2 
        eig(0,i) =  kr/( kr*kr + ki*ki );
        eig(1,i) = -ki/( kr*kr + ki*ki );
      }

      // printF("Eigenvalue %d : k=%18.14e + %18.14e I \n",i,kr,ki);

      // ierr = EPSGetEigenvector(eps,i,xr,xi);CHKERRQ(ierr);

      // ierr = VecView(xr,viewer);CHKERRQ(ierr);
      // if (!ishermitian) { ierr = VecView(xi,viewer);CHKERRQ(ierr); }

      if( i<numEigenVectors )
      {
        // ---- Save the first eigenvector ----
        // printF("Save eigenvector %d to the grid function.\n",i);

        PetscScalar *xrv;
        VecGetArray(xr,&xrv);  // get the local array from Petsc
        ierr = VecGetOwnershipRange(xr,&Istart,&Iend);CHKERRQ(ierr);

        if( useNew )
        {
          for(int II=Istart; II<Iend; II++ ) 
          {
            getLocalIndex( II,i1,i2,i3 ); 
            // printF("II=%d, i1=%d, i2=%d\n",II,i1,i2);

            assert( i1>=n1a && i1<=n1b && i2>=n2a && i2<=n2b );
            u(i1,i2,i3,i) = xrv[II];
          }
        }
        else
        {
          for (int II=Istart; II<Iend; II++) 
          {
            // II = i1 + n*( i2 )
            int i2 = II/n, i1 = II-i2*n, i3=0;
            // printF("II=%d: i1=%i, i2=%d\n",II,i1,i2);
            assert( i1<u.getBound(0) && i2<u.getBound(1) );
            u(i1+1,i2+1,i3,i) = xrv[II];
          }          

        }
      }
    }
    // ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
  }

  /*
     Free work space
  */
  ierr = EPSDestroy(&eps);CHKERRQ(ierr);
  ierr = MatDestroy(&A);CHKERRQ(ierr);
  ierr = MatDestroy(&B);CHKERRQ(ierr);
  ierr = VecDestroy(&xr);CHKERRQ(ierr);
  ierr = VecDestroy(&xi);CHKERRQ(ierr);
  if (nini > 0) {
    ierr = VecDestroyVecs(nini,&Iv);CHKERRQ(ierr);
  }
  if (ncon > 0) {
    ierr = VecDestroyVecs(ncon,&Cv);CHKERRQ(ierr);
  }
  // ierr = SlepcFinalize();


}// end compute Eigenvalues 


// ==================================================================================
/// \brief Compute the pressure from the displacement
// ==================================================================================
int getPressureFromDisplacement( realCompositeGridFunction & uv, realCompositeGridFunction & p, int orderOfAccuracy, real mu  )
{
  CompositeGrid & cg = *uv.getCompositeGrid();
  const int numberOfDimensions = cg.numberOfDimensions();

  Oges solver( cg ); 
                      // create a solver
  // solver.set(OgesParameters::THEsolverType,solverType);

  int stencilSize = orderOfAccuracy+1;
  CompositeGridOperators op(cg);                            // create some differential operators
  op.setStencilSize(stencilSize);
  op.setOrderOfAccuracy(orderOfAccuracy);  

  IntegerArray boundaryConditions(2,3,cg.numberOfComponentGrids());
  RealArray bcData(2,2,3,cg.numberOfComponentGrids());
  boundaryConditions=OgesParameters::neumann;
  bcData=0.;
  solver.setEquationAndBoundaryConditions( OgesParameters::laplaceEquation,op,boundaryConditions,bcData);

  Range all;
  realCompositeGridFunction f(cg,all,all,all);

  f=0.;

  Index Ib1,Ib2,Ib3;
  Index Ig1,Ig2,Ig3;
  // ---- Assign boundary conditions ----
  for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
  {
    MappedGrid & mg = cg[grid];
    realMappedGridFunction & uvg = uv[grid];
    OV_GET_SERIAL_ARRAY(real,f[grid],fLocal);

    ForBoundary(side,axis)
    {
      if( mg.boundaryCondition(side,axis)>0  )
      {
        getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
        getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3);

        // BC: p.n = n.( mu *(u.xx + u.yy)
        int is=1-2*side; 
        if( axis==0 )
        {
          fLocal(Ig1,Ig2,Ig3) = (-is*mu)*uvg.xx(Ib1,Ib2,Ib3,0)(Ib1,Ib2,Ib3,0);
        }
        else
        {
          fLocal(Ig1,Ig2,Ig3) = (-is*mu)*uvg.yy(Ib1,Ib2,Ib3,1)(Ib1,Ib2,Ib3,1);
        }
      }
    }
  }

  p=0.;  // initial guess for iterative solvers
  real time0=getCPU();
  solver.solve( p,f );   // solve the equations
  real time= ParallelUtility::getMaxValue(getCPU()-time0);
  printF("\n*** getPressureFromDisplacement : max residual=%8.2e, time for pressure solve = %8.2e (iterations=%i) ***\n",
         solver.getMaximumResidual(),time,solver.getNumberOfIterations());


  return 0;
}



// ==================================================================================
// ================================ MAIN ============================================
// ==================================================================================
int main(int argc,char **argv)
{

  Overture::start(argc,argv);  // initialize Overture

  SlepcInitialize(&argc,&argv,(char*)0,help);  

  aString commandFileName="";
  aString problem = "laplace"; 
  bool plotOption=true;
  aString nameOfShowFile=""; 

  int debug=0;
  int numPoints=101;
  int nx=52, ny=52; 
  int numEigenValues  = 1; // number of eigenvalues to compute 
  int numEigenVectors = 1; // number of eigenvectors to save
  int orderOfAccuracy = 2 ;
  real tol=1.e-8; 

  real rho=1., mu=1.;

  int includePressure=0;  // solve for pressure as well as psi

  // eigOption = 0 : =solve Ax =kBx for smallest k, 
  //           = 1 : solve Bx = k A x for largest k 
  int eigOption = 0;
  Real eigSign = 1.;  // use to change sign of the eigenfunction
  
  int eigc=0; // which eigen-vector to choose **make this an option***

  real xa=0., xb=1., ya=0., yb=1.;

  printF("Usage: genEigs [-debug=<i>]\n");
  int len=0;
  if( argc > 1 )
  { 
    for( int i=1; i<argc; i++ )
    {
      aString arg = argv[i];
      if( arg=="-noplot" || arg=="noplot" )
      {
        plotOption=false;
      }
      else if( (len=arg.matches("-problem="))  )
      {
        problem = arg(len,arg.length()-1);
        printF("Setting problem=[%s]\n",(const char*)problem);
      }
      else if( (len=arg.matches("-show="))  )
      {
        nameOfShowFile = arg(len,arg.length()-1);
        printF("Setting nameOfShowFile=[%s]\n",(const char*)nameOfShowFile);
      }      
      else if( arg(0,6)=="-debug=" )
      {
        sScanF(arg(7,arg.length()-1),"%i",&debug);
        printF("Setting debug=%i\n",debug);
      }
      else if( (len=arg.matches("-orderOfAccuracy="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&orderOfAccuracy);
        printF("Setting orderOfAccuracy=%d\n",orderOfAccuracy);
      }
      else if( (len=arg.matches("-order="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&orderOfAccuracy);
        printF("Setting orderOfAccuracy=%d\n",orderOfAccuracy);
      } 

      else if( (len=arg.matches("-includePressure="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&includePressure);
        printF("Setting includePressure=%d\n",includePressure);
      }  

      else if( (len=arg.matches("-eigOption="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&eigOption);
        printF("Setting eigOption=%d\n",eigOption);
      }  

      else if( (len=arg.matches("-eigc="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&eigc);
        printF("Setting eigc=%d\n",eigc);
      }                      

      else if( (len=arg.matches("-nx="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&nx);
        printF("Setting nx=%d\n",nx);
      }

      else if( (len=arg.matches("-tol="))  )
      {
        sScanF(arg(len,arg.length()-1),"%e",&tol);
        printF("Setting tol=%e\n",tol);
      }

      else if( (len=arg.matches("-xb="))  )
      {
        sScanF(arg(len,arg.length()-1),"%e",&xb);
        printF("Setting xb=%e\n",xb);
      }      
      else if( (len=arg.matches("-yb="))  )
      {
        sScanF(arg(len,arg.length()-1),"%e",&yb);
        printF("Setting yb=%e\n",yb);
      }  

      else if( (len=arg.matches("-eigSign="))  )
      {
        sScanF(arg(len,arg.length()-1),"%e",&eigSign);
        printF("Setting eigSign=%e\n",eigSign);
      }

      else if( (len=arg.matches("-ny="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&ny);
        printF("Setting ny=%d\n",ny);
      }
      else if( (len=arg.matches("-numEigenValues="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&numEigenValues);
        printF("Setting numEigenValues=%d\n",numEigenValues);
      }          
      else if( (len=arg.matches("-numEigenVectors="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&numEigenVectors);
        printF("Setting numEigenVectors=%d\n",numEigenVectors);
      }         
      else if( commandFileName=="" )
      {
        commandFileName=arg;    
        printf("genEigs: reading commands from file [%s]\n",(const char*)commandFileName);
      }
    }
  }
  else
  {
    printF("Usage: `genEigs [-noplot] [-g=<gridName>] [file.cmd] [-debug=<value>] ' \n");
  }
  
  GenericGraphicsInterface & gi = *Overture::getGraphicsInterface("genEigs",plotOption,argc,argv);
  PlotStuffParameters psp;

  // By default start saving the command file called:
  aString logFile="genEigs.cmd";
  gi.saveCommandFile(logFile);
  printF("User commands are being saved in the file `%s'\n",(const char *)logFile);

  aString outputFileName="genEigs.log";
  FILE *outFile = NULL;
  

  // read from a command file if given
  if( commandFileName!="" )
  {
    printF("read command file =[%s].\n",(const char*)commandFileName);
    gi.readCommandFile(commandFileName);
  }

  int numGhost = orderOfAccuracy/2;

  const int numberOfDimensions=2;

  int numberOfComponents=1;
  if( problem=="laplace" )
  {
    numberOfComponents=1;
  }
  else if( problem=="ile" )
  {
    // Incompressible elasticity
    if( includePressure )
    {
      numberOfComponents=2; 
    }
  }
  else
  {
   OV_ABORT("ERROR: unknown problem");
  }

  SquareMapping square(xa,xb,ya,yb);                   // Make a mapping
  square.setGridDimensions(axis1,nx);                  // axis1==0, set no. of grid points
  square.setGridDimensions(axis2,ny);                  // axis2==1, set no. of grid points

  MappedGrid mg(square);   
  ForBoundary(side,axis)
  {
    if( side==1 && axis==(numberOfDimensions-1) )
      mg.setNumberOfGhostPoints(side,axis,numGhost+1);  // add one for extra equations
    else
      mg.setNumberOfGhostPoints(side,axis,numGhost);
  }    

  // Make a CompositeGrid                        
  CompositeGrid cg(mg.numberOfDimensions(),1);
  cg[0].reference(mg);   
  cg.updateReferences();

  cg.update(MappedGrid::THEmask | MappedGrid::THEvertex | MappedGrid::THEcenter);  


  
  Range all;                                   // a null Range is used as a place-holder below for the coordinates
  int totalNumberOfComponents = numEigenVectors*numberOfComponents;
  realMappedGridFunction u(mg,all,all,all,totalNumberOfComponents);  // create a grid function
  u.setName("v");                 // give names to grid function ...
  for( int i=0, k=0; i<numEigenVectors; i++ )
  {
    if( numberOfComponents==1 )
    {
      u.setName(sPrintF("v%d",i), i);
    }
    else
    {
      for( int j=0; j<numberOfComponents; j++ )
      {
        u.setName(sPrintF("v%d_%d",i,j),k); k++; 
      }
    }
  }
  Index I1,I2,I3; 
  getIndex(mg.dimension(),I1,I2,I3);                        // assign I1,I2,I3 from dimension

  u=0.;
  // u(I1,I2,I3,0)=sin(Pi*mg.vertex()(I1,I2,I3,axis1))         // component 0 : sin(pi*x)*cos(pi*y)
  //              *cos(Pi*mg.vertex()(I1,I2,I3,axis2));        
  // u(I1,I2,I3,1)=cos(Pi*mg.vertex()(I1,I2,I3,axis1))         // component 1 : cos(pi*x)*sin(pi*y)
  //              *sin(Pi*mg.vertex()(I1,I2,I3,axis2));       

 

  CompositeGridOperators cgop(cg);
  cgop.setOrderOfAccuracy(orderOfAccuracy);
  MappedGridOperators & op = cgop[0];

  u.setOperators(op);

  const int u1c=0, u2c=1, pc=2, psic=3;
  realCompositeGridFunction uv(cg,all,all,all,numberOfDimensions+2);
  uv.setName("u1",u1c);  
  uv.setName("u2",u2c);  
  uv.setName("p",pc); 
  uv.setName("psi",psic); 
  uv.setOperators(cgop);
  realCompositeGridFunction p(cg,all,all,all);
  p.setName("p",0);
  p.setOperators(cgop);

  // // Create the object that knows how to evaluate the boundary of the eye-lid
  // EyeCurves eyeCurves;
  
  real time=0.; // plot curve at this time
  
  // ========== create the GUI and dialog ================
  GUIState dialog;
  dialog.setWindowTitle("Eigenvalues Code");
  dialog.setExitCommand("exit", "exit");

  aString cmds[] = {"compute",
                    "contour",
                    "check",
                    "erase",
                    "save file",
                    "" };
  int numberOfPushButtons=0;  // number of entries in cmds
  while( cmds[numberOfPushButtons]!="" ){numberOfPushButtons++;}; // 
  int numRows=(numberOfPushButtons+1)/2;
  dialog.setPushButtons( cmds, cmds, numRows ); 

  const int numberOfTextStrings=15;  // max number allowed
  aString textLabels[numberOfTextStrings];
  aString textStrings[numberOfTextStrings];

  int nt=0;
  textLabels[nt] = "time:";  sPrintF(textStrings[nt],"%g",time);  nt++; 
  textLabels[nt] = "numPoints:";  sPrintF(textStrings[nt],"%i",numPoints);  nt++; 
  // null strings terminal list
  textLabels[nt]="";   textStrings[nt]="";  assert( nt<numberOfTextStrings );
  dialog.setTextBoxes(textLabels, textLabels, textStrings);

  gi.pushGUI(dialog);
  gi.appendToTheDefaultPrompt("genEigs>");
  psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,true);

  RealArray eig; 
 
  aString answer,buff;  
  for( ;; )
  {
    gi.getAnswer(answer,"");  
 
    if( answer=="continue" )
    {
      break;
    }
    else if( answer=="exit" || answer=="done" )
    {
      break;
    }
    else if( answer=="compute" )
    {
      computeEigenvalues( problem,numberOfComponents, orderOfAccuracy, numEigenValues,numEigenVectors, eig, u, tol, eigOption );

      printF("\n======================== GenEigs problem=%s =======================\n",(const char*)problem);
      printF(" nx=%d, ny=%d, orderOfAccuracy=%d\n",nx,ny,orderOfAccuracy);
      printF("===================================================================\n");
      for( int i=0; i<numEigenVectors; i++ )
      {
        printF("Eigenvalue %d : k=%18.14e + %18.14e I",i,eig(0,i),eig(1,i));
        if( problem=="laplace" && i<=6 )
        {
          // --- Eigenvalues of the -Laplacian on the unit square ---
          real eigTrue = i==0 ? 2*Pi*Pi : 
                         i==1 ? SQR(Pi) + SQR(2.*Pi) :
                         i==2 ? SQR(Pi) + SQR(2.*Pi) : 
                         i==3 ? SQR(2.*Pi) + SQR(2.*Pi) :
                         i==4 ? SQR(3.*Pi) + SQR(1.*Pi) :
                         i==5 ? SQR(3.*Pi) + SQR(1.*Pi) :
                                SQR(2.*Pi) + SQR(3.*Pi) ;
          printF(",  true=%18.14e, err=%8.2e",eigTrue,fabs(eig(0,i)-eigTrue));
        }
        printF("\n");
      }
    }    
    else if( answer=="contour" )
    {
      gi.erase();
      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,false);      
      psp.set(GI_TOP_LABEL,sPrintF("Eigenvector"));  // set title
      PlotIt::contour(gi, u,psp );
      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,true);      
    }    
    else if( dialog.getTextValue(answer,"time:","%g",time) ){}// 
    else if( dialog.getTextValue(answer,"numPoints:","%i",numPoints) ){}// 
    else if( answer=="erase" )
    {
      gi.erase();
    }
    else if( answer=="check" && problem=="ile" )
    {  

      // --- check the ILE solution ----
      printF("--- check the incompressible elasticity solution : eigc=%d---\n",eigc);

      // first eigenvalue: 
      const Real lambda = eig(0,eigc);        


      Index I1,I2,I3;
      Index Ibv[3], &Ib1=Ibv[0], &Ib2=Ibv[1], &Ib3=Ibv[2];
      Index Igv[3], &Ig1=Igv[0], &Ig2=Igv[1], &Ig3=Igv[2];
      BoundaryConditionParameters extrapParams;
      extrapParams.orderOfExtrapolation=orderOfAccuracy+1;


      for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
      {
        MappedGrid & mg = cg[grid];
        realMappedGridFunction & uvg = uv[grid];
        realMappedGridFunction & pg  = p[grid];
        OV_GET_SERIAL_ARRAY(real,uvg,uLocal);

        const bool isRectangular = mg.isRectangular();
        real dx[3]={1.,1.,1.};
        if( isRectangular )
          mg.getDeltaX(dx);

        getIndex(mg.dimension(),I1,I2,I3);

        uv[grid](I1,I2,I3,0) =  u.y(I1,I2,I3,eigc)(I1,I2,I3,eigc); 
        uv[grid](I1,I2,I3,1) = -u.x(I1,I2,I3,eigc)(I1,I2,I3,eigc);

        // First extrap all ghost 
        for( int ghost=1; ghost<=numGhost; ghost++ )
        {
          extrapParams.ghostLineToAssign=ghost;
          uvg.applyBoundaryCondition(Range(0,1),BCTypes::extrapolate,BCTypes::allBoundaries,0.,0.,extrapParams);
        }  

        if( orderOfAccuracy==2 )
        {
          // apply BC's to u1 and u2 -- maybe not needed if use use CBCs when solving for the eigenfunction
          ForBoundary(side,axis)
          {
            getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
            getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3);

            const int is = 1-2*side; 
            if( axis==0 )
            {
              // u1.x = 0 
              uvg.applyBoundaryCondition(u1c,BCTypes::neumann,    BCTypes::BCTypes::boundary(side,axis),0.);
              // uvg.applyBoundaryCondition(u2c,BCTypes::extrapolate,BCTypes::BCTypes::boundary(side,axis),0.);

              // mu*u2.xx = p.y - lambda*u2  **CHECK ME** TROUBLE: p is NOT KNOWN YET !!
              // uLocal(Ig1,Ig2,Ig3,u2c) = 2.*uLocal(Ib1,Ib2,Ib3,u2c) - uLocal(Ib1+is,Ib2,Ib3,u2c)
              //   + (SQR(dx[0])/mu)*( pg.y(Ib1,Ib2,Ib3)(Ib1,Ib2,Ib3) - lambda*uLocal(Ib1,Ib2,Ib3,u2c) );
            }
            else
            {
              // u2.y = 0 
              uvg.applyBoundaryCondition(u2c,BCTypes::neumann,    BCTypes::BCTypes::boundary(side,axis),0.);
              // uvg.applyBoundaryCondition(u1c,BCTypes::extrapolate,BCTypes::BCTypes::boundary(side,axis),0.);
              // mu*u1.yy = p.x - lambda*u1  ** CHECK ME **
              // uLocal(Ig1,Ig2,Ig3,u1c) = 2.*uLocal(Ib1,Ib2,Ib3,u1c) - uLocal(Ib1,Ib2+is,Ib3,u1c)
              //   + (SQR(dx[1])/mu)*( pg.x(Ib1,Ib2,Ib3)(Ib1,Ib2,Ib3) - lambda*uLocal(Ib1,Ib2,Ib3,u1c) ) ;             
            }

          }
          // ::display(uvg,"uvg after apply BC","%6.3f ");
        }
        else if( orderOfAccuracy==4 )
        {
          // apply BC's to u1 and u2 -- maybe not needed if use use CBCs when solving for the eigenfunction


          // u.x = 0 
          //   u(-2) -8*u(-1) + 8*u(1) -u(2) = 0 
          //   u(-2) = 5*u(-1) -10*u(0) +10*u(1) -5*u(2) + u(3)
          //   -3*u(1) -10*u(0) +18*u(1) -6*u(2) + u(3) = 0
          const Real cex41= (-10./3.), cex42=6., cex43=-2., cex44=1./3.; 

          ForBoundary(side,axis)
          {
            getBoundaryIndex(mg.gridIndexRange(),side,axis,Ib1,Ib2,Ib3);
            // getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3);

            const int is = 1-2*side; 
            if( axis==0 )
            {
              // u1.x = 0 
              // uvg.applyBoundaryCondition(u1c,BCTypes::neumann,    BCTypes::BCTypes::boundary(side,axis),0.);
              // uvg.applyBoundaryCondition(u2c,BCTypes::extrapolate,BCTypes::BCTypes::boundary(side,axis),0.);

              uLocal(Ib1-is,Ib2,Ib3,u1c) = cex41*uLocal(Ib1     ,Ib2,Ib3,u1c) +
                                           cex42*uLocal(Ib1+  is,Ib2,Ib3,u1c) +
                                           cex43*uLocal(Ib1+2*is,Ib2,Ib3,u1c) +
                                           cex44*uLocal(Ib1+3*is,Ib2,Ib3,u1c);
              uLocal(Ib1-2*is,Ib2,Ib3,u1c) =  5.*uLocal(Ib1-1*is,Ib2,Ib3,u1c) +
                                            -10.*uLocal(Ib1     ,Ib2,Ib3,u1c) +
                                            +10.*uLocal(Ib1+1*is,Ib2,Ib3,u1c) +
                                             -5.*uLocal(Ib1+2*is,Ib2,Ib3,u1c) +                                       
                                             +1.*uLocal(Ib1+3*is,Ib2,Ib3,u1c);                                        

              // // mu*u2.xx = p.y - lambda*u2  **CHECK ME**
              // uLocal(Ig1,Ig2,Ig3,u2c) = 2.*uLocal(Ib1,Ib2,Ib3,u2c) - uLocal(Ib1+is,Ib2,Ib3,u2c)
              //   + (SQR(dx[0])/mu)*( pg.y(Ib1,Ib2,Ib3)(Ib1,Ib2,Ib3) - lambda*uLocal(Ib1,Ib2,Ib3,u2c) );

            }
            else
            {
              // u2.y = 0 
              // uvg.applyBoundaryCondition(u2c,BCTypes::neumann,    BCTypes::BCTypes::boundary(side,axis),0.);
              uLocal(Ib1,Ib2-is,Ib3,u2c) = cex41*uLocal(Ib1,Ib2     ,Ib3,u2c) +
                                           cex42*uLocal(Ib1,Ib2+  is,Ib3,u2c) +
                                           cex43*uLocal(Ib1,Ib2+2*is,Ib3,u2c) +
                                           cex44*uLocal(Ib1,Ib2+3*is,Ib3,u2c);
              uLocal(Ib1,Ib2-2*is,Ib3,u2c) =  5.*uLocal(Ib1,Ib2-1*is,Ib3,u2c) +
                                            -10.*uLocal(Ib1,Ib2     ,Ib3,u2c) +
                                            +10.*uLocal(Ib1,Ib2+1*is,Ib3,u2c) +
                                             -5.*uLocal(Ib1,Ib2+2*is,Ib3,u2c) +                                       
                                             +1.*uLocal(Ib1,Ib2+3*is,Ib3,u2c);   

 
              // uvg.applyBoundaryCondition(u1c,BCTypes::extrapolate,BCTypes::BCTypes::boundary(side,axis),0.);
              // mu*u1.yy = p.x - lambda*u1  ** CHECK ME **
              // uLocal(Ig1,Ig2,Ig3,u1c) = 2.*uLocal(Ib1,Ib2,Ib3,u1c) - uLocal(Ib1,Ib2+is,Ib3,u1c)
              //   + (SQR(dx[1])/mu)*( pg.x(Ib1,Ib2,Ib3)(Ib1,Ib2,Ib3) - lambda*uLocal(Ib1,Ib2,Ib3,u1c) ) ;             
            }

            // for( int ghost=2; ghost<=numGhost; ghost++ )
            // {
            //   extrapParams.ghostLineToAssign=ghost;
            //   uvg.applyBoundaryCondition(Range(0,1),BCTypes::extrapolate,BCTypes::allBoundaries,0.,0.,extrapParams);
            // }            

          }
          // ::display(uvg,"uvg after apply BC","%6.3f ");
        }
      }      

      // for now extrapolate ghost -- could do better
      // if( orderOfAccuracy>4 )
      // {
      //   for( int ghost=1; ghost<=numGhost; ghost++ )
      //   {
      //     extrapParams.orderOfExtrapolation=orderOfAccuracy+1; 
      //     extrapParams.ghostLineToAssign=ghost;
      //     uv.applyBoundaryCondition(Range(0,1),BCTypes::extrapolate,BCTypes::allBoundaries,0.,0.,extrapParams);
      //   }
      // }
      uv.finishBoundaryConditions();


      // Normalize eigen-solution (u1,u2) to have max norm of 1
      const Real scaleFactor = max( maxNorm(uv,0), maxNorm(uv,1) );
      for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
      {
        uv[grid](all,all,all,Range(0,1)) *= eigSign/scaleFactor;
      }  

      // Normalize eigen-solution psi to have max norm of 1
      const Real psiScaleFactor = maxNorm(u,eigc);
      u(all,all,all,eigc) *= eigSign/psiScaleFactor;

      getPressureFromDisplacement( uv, p, orderOfAccuracy,mu );


      for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
      {
        MappedGrid & mg = cg[grid];
        getIndex(mg.dimension(),I1,I2,I3);
        uv[grid](I1,I2,I3,pc)   = p[grid](I1,I2,I3);
        uv[grid](I1,I2,I3,psic) = u(I1,I2,I3,eigc);  // psi : chosen eigenvector 
      }



      if( nameOfShowFile != "" )
      {
        // -- save a show file ---
        Ogshow show( nameOfShowFile );                               // create a show file
        show.saveGeneralComment("Results from genEigs");    // save a general comment in the show file

        ListOfShowFileParameters showFileParams;
        showFileParams.push_back(ShowFileParameter("u1Component",u1c));
        showFileParams.push_back(ShowFileParameter("u2Component",u2c));
        show.saveGeneralParameters(showFileParams);

        show.startFrame();                                             // start a new frame
        aString buff;
        show.saveComment(0,sPrintF(buff,"%s: order=%d, nx=%d, ny=%d",(const char*)problem,orderOfAccuracy,nx,ny));  
        // show.saveComment(1,sPrintF(buffer,"  t=%e ",t));               // comment 1 (shown on plot)
        show.saveSolution( uv );                                        // save the current grid function
        show.endFrame(); 
        show.close();   
        printF("Wrote show file=[%s]\n",(const char*)nameOfShowFile);
      }   


      // ---- check the residual ----
      realCompositeGridFunction res(cg,all,all,all,2);
      res.setName("u1res",0);
      res.setName("u2res",1);
      res = 0.;


      Real resMax; 
      for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
      {
        MappedGrid & mg = cg[grid];
        realMappedGridFunction & uvg = uv[grid];
        realMappedGridFunction & pg = p[grid];

        int extra=-1;
        getIndex(mg.gridIndexRange(),I1,I2,I3,extra);

        OV_GET_SERIAL_ARRAY(real,res[grid],resLocal);

        resLocal(I1,I2,I3,0) = mu*( uvg.xx(I1,I2,I3,0)(I1,I2,I3,0) + uvg.yy(I1,I2,I3,0)(I1,I2,I3,0) ) 
                               - pg.x(I1,I2,I3,0)(I1,I2,I3,0) + lambda*uvg(I1,I2,I3,0);
        resMax = max(fabs(resLocal(I1,I2,I3,0)));
        printF("grid=%d: lambda=%9.3e, max-residual in mu*Delta(u1) -p.x + lambda*u1  =%8.2e\n",grid,lambda,resMax);

        resLocal(I1,I2,I3,1) = mu*( uvg.xx(I1,I2,I3,1)(I1,I2,I3,1) + uvg.yy(I1,I2,I3,1)(I1,I2,I3,1) ) 
                               - pg.y(I1,I2,I3,0)(I1,I2,I3,0) + lambda*uvg(I1,I2,I3,1);
        resMax = max(fabs(resLocal(I1,I2,I3,1)));
        printF("grid=%d: lambda=%9.3e, max-residual in mu*Delta(u2) -p.y + lambda*u2  =%8.2e\n",grid,lambda,resMax);        

      }     
      Real resL2 = max( l2Norm(res,0), l2Norm(res,1) );
      printF(" L2-norm residual =%8.2e\n",resL2);

      // res.display("res");

      gi.erase();      

      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,false);      
      psp.set(GI_TOP_LABEL,sPrintF("Residual"));  // set title
      PlotIt::contour(gi, res,psp );
      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,true); 
      gi.erase();      

      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,false);      
      psp.set(GI_TOP_LABEL,sPrintF("Displacement and pressure"));  // set title
      PlotIt::contour(gi, uv,psp );
      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,true);  


          

    }  
    // else if( answer=="movie" )
    // {
    //   // --- plot a movie of the eye motion ---

    //   // fix the plot bounds as the eye moves 
    //   RealArray xBound(2,3);
    //   xBound(0,0)=-1.2; xBound(1,0)= 1.2;
    //   xBound(0,1)=-1.2; xBound(1,1)= 1.2;
    //   xBound(0,2)=-1.;  xBound(1,2)= 1.;

    //   real dt=.005*Pi, tFinal=10*Pi;
    //   int nStep=int( tFinal/dt + .5 );
    //   dt = tFinal/(nStep);

    //   real yMax=-1.e10; // keep track of the largest y value of the eye-lid 

    //   RealArray x;
    //   for( int step=0; step<nStep; step++ )
    //   {
    //     real t=step*dt;
        
    //     eyeCurves.getEyeCurve( x,t,numPoints );

    //     Range R = x.dimension(0);
    //     real yTop = max(x(R,1));
    //     if( yTop>yMax )
    //     {
    //       yMax=yTop;
    //     }
    //     else if( yTop>yMax*(.99999) )
    //     {
    //       printF("Eye reaches yMax=%9.3e at t=%9.3e t/(2*pi)=%9.3e\n",yMax,t,t/twoPi);
    //     }
        
    //     gi.erase();
    //     psp.set(GI_TOP_LABEL,sPrintF(buff,"genEigs: t=%9.2e, yMax=%8.2e",t,yMax));
    //     plotCurve( x, gi,psp );
    //     gi.setGlobalBound(xBound); // set plot bounds         

    //     gi.redraw(true);
    //   }

    // }

    // else if( answer=="save file" )
    // {
    //   aString fileName = "eyeCurveDataPoints.dat";
    //   eyeCurves.saveEyeCurve( time, numPoints, fileName );
    //   printF("Eye coordinates written to file=[%s]\n",(const char*)fileName);
    // }
    
    else
    {
      printF("Unknown response=[%s]\n",(const char*)answer);
    }
  }
  

  gi.unAppendTheDefaultPrompt();
  gi.popGUI(); // restore the previous GUI


  int ierr = SlepcFinalize();

  Overture::finish();  

  return 0;
}

