// ==================================================================================================
// Solve a generalized eigenvalue problem with SLEPc
//            A x = k B x
// 
// Started from SLEPc examples:
//      src/eps/examples/tutorials/ex2.c  : Laplace
//      src/eps/examples/tutorials/ex7.c  : generalized eig problem, read matrices from files
// ==================================================================================================






static char help[] = "Solves a generalized eigensystem Ax=kBx with matrices loaded from a file.\n"
  "This example works for both real and complex numbers.\n\n"
  "The command line options are:\n"
  "  -f1 <filename>, where <filename> = matrix (A) file in PETSc binary form.\n"
  "  -f2 <filename>, where <filename> = matrix (B) file in PETSc binary form.\n"
  "  -evecs <filename>, output file to save computed eigenvectors.\n"
  "  -ninitial <nini>, number of user-provided initial guesses.\n"
  "  -finitial <filename>, where <filename> contains <nini> vectors (binary).\n"
  "  -nconstr <ncon>, number of user-provided constraints.\n"
  "  -fconstr <filename>, where <filename> contains <ncon> vectors (binary).\n\n";

#include <slepceps.h>

#include "Overture.h"
#include "display.h"
#include "PlotStuff.h"  
#include "SquareMapping.h"  



// ==================================================================================
// Fill in the PETSc matrices A and B 
//          minus-Laplacian 
// ==================================================================================
int
fillMatrixLaplacian( MappedGrid & mg, Mat & A, Mat & B  )
{
  PetscBool flag;
  int Istart,Iend,ierr;

  const bool isRectangular = mg.isRectangular();
  real dx[3]={1.,1.,1.};
  if( isRectangular )
    mg.getDeltaX(dx);

  assert( isRectangular );

  const IntegerArray & gid = mg.gridIndexRange();

  // No boundary points: 
  int n = gid(1,0)-gid(0,0)+1 - 2;
  int m = gid(1,1)-gid(0,1)+1 - 2;

  int N = n*m;

    // ----- MATRIX A -----

  ierr = MatCreate(PETSC_COMM_WORLD,&A);CHKERRQ(ierr);
  ierr = MatSetSizes(A,PETSC_DECIDE,PETSC_DECIDE,N,N);CHKERRQ(ierr);
  ierr = MatSetFromOptions(A);CHKERRQ(ierr);
  ierr = MatSetUp(A);CHKERRQ(ierr);

  ierr = MatGetOwnershipRange(A,&Istart,&Iend);CHKERRQ(ierr);

  Real dx2i = 1./(dx[0]*dx[0]);
  Real dy2i = 1./(dx[1]*dx[1]);
  Real diag = 2.*dx2i + 2.*dy2i; 
  for( int II=Istart; II<Iend; II++ ) 
  {
    int i = II/n; 
    int j = II-i*n;
    if (i>0) {   ierr = MatSetValue(A,II,II-n,-dy2i,INSERT_VALUES);CHKERRQ(ierr); }
    if (i<m-1) { ierr = MatSetValue(A,II,II+n,-dy2i,INSERT_VALUES);CHKERRQ(ierr); }

    if (j>0) {   ierr = MatSetValue(A,II,II-1,-dx2i,INSERT_VALUES);CHKERRQ(ierr); }
    if (j<n-1) { ierr = MatSetValue(A,II,II+1,-dx2i,INSERT_VALUES);CHKERRQ(ierr); }

    ierr =              MatSetValue(A,II,II  , diag,INSERT_VALUES);CHKERRQ(ierr);

    // if (i>0) { ierr = MatSetValue(A,II,II-n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
    // if (i<m-1) { ierr = MatSetValue(A,II,II+n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
    // if (j>0) { ierr = MatSetValue(A,II,II-1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
    // if (j<n-1) { ierr = MatSetValue(A,II,II+1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
    // ierr = MatSetValue(A,II,II,4.0,INSERT_VALUES);CHKERRQ(ierr);

  }

  ierr = MatAssemblyBegin(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  ierr = MatAssemblyEnd(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);



  // ----- MATRIX B = I -----

  ierr = MatCreate(PETSC_COMM_WORLD,&B);CHKERRQ(ierr);
  ierr = MatSetSizes(B,PETSC_DECIDE,PETSC_DECIDE,N,N);CHKERRQ(ierr);
  ierr = MatSetFromOptions(B);CHKERRQ(ierr);
  ierr = MatSetUp(B);CHKERRQ(ierr);

  ierr = MatGetOwnershipRange(B,&Istart,&Iend);CHKERRQ(ierr);
  for( int II=Istart; II<Iend; II++) 
  {
    int i = II/n; 
    int j = II-i*n;
    // if (i>0) { ierr = MatSetValue(B,II,II-n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
    // if (i<m-1) { ierr = MatSetValue(B,II,II+n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
    // if (j>0) { ierr = MatSetValue(B,II,II-1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
    // if (j<n-1) { ierr = MatSetValue(B,II,II+1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
    ierr = MatSetValue(B,II,II,1.0,INSERT_VALUES);CHKERRQ(ierr);
  }

  ierr = MatAssemblyBegin(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  ierr = MatAssemblyEnd(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);

  return 0;
}


// ==================================================================================
// Compute the eigenvalues using SLEPc
// ==================================================================================
int
computeEigenvalues( int numEigenValues, int numEigenVectors, realMappedGridFunction & u  )
{

  Mat            A,B;             /* matrices */
  EPS            eps;             /* eigenproblem solver context */
  EPSType        type;
  PetscReal      tol;
  Vec            xr,xi,*Iv,*Cv;
  PetscInt       nev,maxit,i,its,lits,nconv,nini=0,ncon=0;
  char           filename[PETSC_MAX_PATH_LEN];
  PetscViewer    viewer;
  PetscBool      flg,evecs,ishermitian;
  PetscErrorCode ierr;

  // SlepcInitialize(&argc,&argv,(char*)0,help);


  PetscBool      flag;
  int j,N,m,n,Istart,Iend,II;

  // ierr = PetscOptionsGetInt(NULL,"-n",&n,NULL);CHKERRQ(ierr);
  // ierr = PetscOptionsGetInt(NULL,"-m",&m,&flag);CHKERRQ(ierr);
  // if (!flag) m=n;

  MappedGrid & mg = *u.getMappedGrid();
  const bool isRectangular = mg.isRectangular();
  real dx[3]={1.,1.,1.};
  if( isRectangular )
    mg.getDeltaX(dx);

  assert( isRectangular );

  const IntegerArray & gid = mg.gridIndexRange();
  n = gid(1,0)-gid(0,0)+1 - 2;
  m = gid(1,1)-gid(0,1)+1 - 2;


  N = n*m;
  ierr = PetscPrintf(PETSC_COMM_WORLD,"\n Generalized Eigenavlue Problem Ax = k Bx, N=%D (%Dx%D grid)\n\n",N,n,m);CHKERRQ(ierr);



   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   //      Load the matrices that define the eigensystem, Ax=kBx
   //   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

//   ierr = PetscPrintf(PETSC_COMM_WORLD,"\nGeneralized eigenproblem stored in file.\n\n");CHKERRQ(ierr);
//   ierr = PetscOptionsGetString(NULL,"-f1",filename,PETSC_MAX_PATH_LEN,&flg);CHKERRQ(ierr);
//   if (!flg) SETERRQ(PETSC_COMM_WORLD,1,"Must indicate a file name for matrix A with the -f1 option");

// #if defined(PETSC_USE_COMPLEX)
//   ierr = PetscPrintf(PETSC_COMM_WORLD," Reading COMPLEX matrices from binary files...\n");CHKERRQ(ierr);
// #else
//   ierr = PetscPrintf(PETSC_COMM_WORLD," Reading REAL matrices from binary files...\n");CHKERRQ(ierr);
// #endif
//   ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_READ,&viewer);CHKERRQ(ierr);
//   ierr = MatCreate(PETSC_COMM_WORLD,&A);CHKERRQ(ierr);
//   ierr = MatSetFromOptions(A);CHKERRQ(ierr);
//   ierr = MatLoad(A,viewer);CHKERRQ(ierr);
//   ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);

//   ierr = PetscOptionsGetString(NULL,"-f2",filename,PETSC_MAX_PATH_LEN,&flg);CHKERRQ(ierr);
//   if (flg) {
//     ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_READ,&viewer);CHKERRQ(ierr);
//     ierr = MatCreate(PETSC_COMM_WORLD,&B);CHKERRQ(ierr);
//     ierr = MatSetFromOptions(B);CHKERRQ(ierr);
//     ierr = MatLoad(B,viewer);CHKERRQ(ierr);
//     ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
//   } else {
//     ierr = PetscPrintf(PETSC_COMM_WORLD," Matrix B was not provided, setting B=I\n\n");CHKERRQ(ierr);
//     B = NULL;
//   }


  // ---- Fill Matrix A and B for the minus Laplacian ----
  fillMatrixLaplacian( mg,A, B );

  // // ----- MATRIX A -----

  // ierr = MatCreate(PETSC_COMM_WORLD,&A);CHKERRQ(ierr);
  // ierr = MatSetSizes(A,PETSC_DECIDE,PETSC_DECIDE,N,N);CHKERRQ(ierr);
  // ierr = MatSetFromOptions(A);CHKERRQ(ierr);
  // ierr = MatSetUp(A);CHKERRQ(ierr);

  // ierr = MatGetOwnershipRange(A,&Istart,&Iend);CHKERRQ(ierr);

  // Real dx2i = 1./(dx[0]*dx[0]);
  // Real dy2i = 1./(dx[1]*dx[1]);
  // Real diag = 2.*dx2i + 2.*dy2i; 
  // for (II=Istart;II<Iend;II++) {
  //   i = II/n; j = II-i*n;
  //   if (i>0) {   ierr = MatSetValue(A,II,II-n,-dy2i,INSERT_VALUES);CHKERRQ(ierr); }
  //   if (i<m-1) { ierr = MatSetValue(A,II,II+n,-dy2i,INSERT_VALUES);CHKERRQ(ierr); }

  //   if (j>0) {   ierr = MatSetValue(A,II,II-1,-dx2i,INSERT_VALUES);CHKERRQ(ierr); }
  //   if (j<n-1) { ierr = MatSetValue(A,II,II+1,-dx2i,INSERT_VALUES);CHKERRQ(ierr); }

  //   ierr =              MatSetValue(A,II,II  , diag,INSERT_VALUES);CHKERRQ(ierr);

  //   // if (i>0) { ierr = MatSetValue(A,II,II-n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (i<m-1) { ierr = MatSetValue(A,II,II+n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (j>0) { ierr = MatSetValue(A,II,II-1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (j<n-1) { ierr = MatSetValue(A,II,II+1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // ierr = MatSetValue(A,II,II,4.0,INSERT_VALUES);CHKERRQ(ierr);

  // }

  // ierr = MatAssemblyBegin(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  // ierr = MatAssemblyEnd(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);



  // // ----- MATRIX B = I -----

  // ierr = MatCreate(PETSC_COMM_WORLD,&B);CHKERRQ(ierr);
  // ierr = MatSetSizes(B,PETSC_DECIDE,PETSC_DECIDE,N,N);CHKERRQ(ierr);
  // ierr = MatSetFromOptions(B);CHKERRQ(ierr);
  // ierr = MatSetUp(B);CHKERRQ(ierr);

  // ierr = MatGetOwnershipRange(B,&Istart,&Iend);CHKERRQ(ierr);
  // for (II=Istart;II<Iend;II++) {
  //   i = II/n; j = II-i*n;
  //   // if (i>0) { ierr = MatSetValue(B,II,II-n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (i<m-1) { ierr = MatSetValue(B,II,II+n,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (j>0) { ierr = MatSetValue(B,II,II-1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   // if (j<n-1) { ierr = MatSetValue(B,II,II+1,-1.0,INSERT_VALUES);CHKERRQ(ierr); }
  //   ierr = MatSetValue(B,II,II,1.0,INSERT_VALUES);CHKERRQ(ierr);
  // }

  // ierr = MatAssemblyBegin(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
  // ierr = MatAssemblyEnd(B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);



  ierr = MatGetVecs(A,NULL,&xr);CHKERRQ(ierr);
  ierr = MatGetVecs(A,NULL,&xi);CHKERRQ(ierr);

  /*
     Read user constraints if available
  */
  ierr = PetscOptionsGetInt(NULL,"-nconstr",&ncon,&flg);CHKERRQ(ierr);
  if (flg) {
    if (ncon<=0) SETERRQ(PETSC_COMM_WORLD,1,"The number of constraints must be >0");
    ierr = PetscOptionsGetString(NULL,"-fconstr",filename,PETSC_MAX_PATH_LEN,&flg);CHKERRQ(ierr);
    if (!flg) SETERRQ(PETSC_COMM_WORLD,1,"Must specify the name of the file storing the constraints");
    ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_READ,&viewer);CHKERRQ(ierr);
    ierr = VecDuplicateVecs(xr,ncon,&Cv);CHKERRQ(ierr);
    for (i=0;i<ncon;i++) {
      ierr = VecLoad(Cv[i],viewer);CHKERRQ(ierr);
    }
    ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
  }

  /*
     Read initial guesses if available
  */
  ierr = PetscOptionsGetInt(NULL,"-ninitial",&nini,&flg);CHKERRQ(ierr);
  if (flg) {
    if (nini<=0) SETERRQ(PETSC_COMM_WORLD,1,"The number of initial vectors must be >0");
    ierr = PetscOptionsGetString(NULL,"-finitial",filename,PETSC_MAX_PATH_LEN,&flg);CHKERRQ(ierr);
    if (!flg) SETERRQ(PETSC_COMM_WORLD,1,"Must specify the name of the file containing the initial vectors");
    ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_READ,&viewer);CHKERRQ(ierr);
    ierr = VecDuplicateVecs(xr,nini,&Iv);CHKERRQ(ierr);
    for (i=0;i<nini;i++) {
      ierr = VecLoad(Iv[i],viewer);CHKERRQ(ierr);
    }
    ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
  }

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                Create the eigensolver and set various options
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /*
     Create eigensolver context
  */
  ierr = EPSCreate(PETSC_COMM_WORLD,&eps);CHKERRQ(ierr);

  /*
     Set operators. In this case, it is a generalized eigenvalue problem
  */
  ierr = EPSSetOperators(eps,A,B);CHKERRQ(ierr);

  /*
     If the user provided initial guesses or constraints, pass them here
  */
  ierr = EPSSetInitialSpace(eps,nini,Iv);CHKERRQ(ierr);
  ierr = EPSSetDeflationSpace(eps,ncon,Cv);CHKERRQ(ierr);

  tol = 1.e-12; 
  PetscInt maxIt = 1000; 
  ierr = EPSSetTolerances(eps,tol,maxIt); CHKERRQ(ierr);

  /*
     Set solver parameters at runtime
  */
  ierr = EPSSetFromOptions(eps);CHKERRQ(ierr);

  PetscInt mpd = PETSC_DEFAULT; // numEigenVectors; // maximum projected dimension, decrease to save space
  printF("Setting numEigenValues=%d, numEigenVectors=%d,\n",numEigenValues,numEigenVectors);
  PetscInt ncv = PETSC_DEFAULT; // numEigenValues*2+1; // size of column space 
  ierr = EPSSetDimensions(eps,numEigenValues,ncv,mpd); CHKERRQ(ierr);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                      Solve the eigensystem
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  ierr = EPSSolve(eps);CHKERRQ(ierr);

  /*
     Optional: Get some information from the solver and display it
  */
  ierr = EPSGetIterationNumber(eps,&its);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD," Number of iterations of the method: %D\n",its);CHKERRQ(ierr);
  ierr = EPSGetOperationCounters(eps,NULL,NULL,&lits);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD," Number of linear iterations of the method: %D\n",lits);CHKERRQ(ierr);
  ierr = EPSGetType(eps,&type);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD," Solution method: %s\n\n",type);CHKERRQ(ierr);

  ierr = EPSGetDimensions(eps,&nev,NULL,NULL);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD," Number of requested eigenvalues: %D\n",nev);CHKERRQ(ierr);

  nev = numEigenValues;

  ierr = EPSGetTolerances(eps,&tol,&maxit);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD," Stopping condition: tol=%.4G, maxit=%D\n",tol,maxit);CHKERRQ(ierr);

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                    Display solution and clean up
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  ierr = EPSPrintSolution(eps,NULL);CHKERRQ(ierr);
  /*
     Save eigenvectors, if requested
  */
  ierr = PetscOptionsGetString(NULL,"-evecs",filename,PETSC_MAX_PATH_LEN,&evecs);CHKERRQ(ierr);

  ierr = EPSGetConverged(eps,&nconv);CHKERRQ(ierr);
  if( nconv>0 && nev>0 ) 
  {
    // ierr = PetscViewerBinaryOpen(PETSC_COMM_WORLD,filename,FILE_MODE_WRITE,&viewer);CHKERRQ(ierr);
    // ierr = EPSIsHermitian(eps,&ishermitian);CHKERRQ(ierr);
    // for (i=0;i<nconv;i++) 
    for( int i=0; i<numEigenVectors; i++ ) 
    {
      // printF("get eigenvector %d (evecs=%d)\n",i,evecs);

      ierr = EPSGetEigenvector(eps,i,xr,xi);CHKERRQ(ierr);
      // ierr = VecView(xr,viewer);CHKERRQ(ierr);
      // if (!ishermitian) { ierr = VecView(xi,viewer);CHKERRQ(ierr); }

      if( i<numEigenVectors )
      {
        // ---- Save the first eigenvector ----
        // printF("Save eigenvector %d to the grid function.\n",i);

        PetscScalar *xrv;
        VecGetArray(xr,&xrv);  // get the local array from Petsc
        ierr = VecGetOwnershipRange(xr,&Istart,&Iend);CHKERRQ(ierr);

        for (int II=Istart; II<Iend; II++) 
        {
          // II = i1 + n*( i2 )
          int i2 = II/n, i1 = II-i2*n, i3=0;
          // printF("II=%d: i1=%i, i2=%d\n",II,i1,i2);
          assert( i1<u.getBound(0) && i2<u.getBound(1) );
          u(i1+1,i2+1,i3,i) = xrv[II];
        }
      }
    }
    // ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
  }

  /*
     Free work space
  */
  ierr = EPSDestroy(&eps);CHKERRQ(ierr);
  ierr = MatDestroy(&A);CHKERRQ(ierr);
  ierr = MatDestroy(&B);CHKERRQ(ierr);
  ierr = VecDestroy(&xr);CHKERRQ(ierr);
  ierr = VecDestroy(&xi);CHKERRQ(ierr);
  if (nini > 0) {
    ierr = VecDestroyVecs(nini,&Iv);CHKERRQ(ierr);
  }
  if (ncon > 0) {
    ierr = VecDestroyVecs(ncon,&Cv);CHKERRQ(ierr);
  }
  // ierr = SlepcFinalize();

}// end compute Eigenvalues 



#undef __FUNCT__
#define __FUNCT__ "main"
int main(int argc,char **argv)
{

  Overture::start(argc,argv);  // initialize Overture

  SlepcInitialize(&argc,&argv,(char*)0,help);  

  aString commandFileName="";
  bool plotOption=true;
  int debug=0;
  int numPoints=101;
  int nx=52, ny=52; 
  int numEigenValues=1; // number of eigenvalues to compute 
  int numEigenVectors=1; // number of eigenvectors to save

  printF("Usage: genEigs [-debug=<i>]\n");
  int len=0;
  if( argc > 1 )
  { 
    for( int i=1; i<argc; i++ )
    {
      aString arg = argv[i];
      if( arg=="-noplot" || arg=="noplot" )
        plotOption=false;
      else if( arg(0,6)=="-debug=" )
      {
        sScanF(arg(7,arg.length()-1),"%i",&debug);
        printF("Setting debug=%i\n",debug);
      }
      else if( (len=arg.matches("-nx="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&nx);
        printF("Setting nx=%d\n",nx);
      }
      else if( (len=arg.matches("-ny="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&ny);
        printF("Setting ny=%d\n",ny);
      }
      else if( (len=arg.matches("-numEigenValues="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&numEigenValues);
        printF("Setting numEigenValues=%d\n",numEigenValues);
      }          
      else if( (len=arg.matches("-numEigenVectors="))  )
      {
        sScanF(arg(len,arg.length()-1),"%i",&numEigenVectors);
        printF("Setting numEigenVectors=%d\n",numEigenVectors);
      }         
      else if( commandFileName=="" )
      {
        commandFileName=arg;    
        printf("genEigs: reading commands from file [%s]\n",(const char*)commandFileName);
      }
    }
  }
  else
  {
    printF("Usage: `genEigs [-noplot] [-g=<gridName>] [file.cmd] [-debug=<value>] ' \n");
  }
  
  GenericGraphicsInterface & gi = *Overture::getGraphicsInterface("genEigs",plotOption,argc,argv);
  PlotStuffParameters psp;

  // By default start saving the command file called:
  aString logFile="genEigs.cmd";
  gi.saveCommandFile(logFile);
  printF("User commands are being saved in the file `%s'\n",(const char *)logFile);

  aString outputFileName="genEigs.log";
  FILE *outFile = NULL;
  

  // read from a command file if given
  if( commandFileName!="" )
  {
    printF("read command file =[%s].\n",(const char*)commandFileName);
    gi.readCommandFile(commandFileName);
  }


  SquareMapping square(0.,1.,0.,1.);                   // Make a mapping, unit square
  square.setGridDimensions(axis1,nx);                  // axis1==0, set no. of grid points
  square.setGridDimensions(axis2,ny);                  // axis2==1, set no. of grid points
  MappedGrid mg(square);                               // MappedGrid for a square
  mg.update(MappedGrid::THEmask | MappedGrid::THEvertex | MappedGrid::THEcenter);    
  
  Range all;                                   // a null Range is used as a place-holder below for the coordinates
  realMappedGridFunction u(mg,all,all,all,numEigenVectors);  // create a grid function
  u.setName("v");                 // give names to grid function ...
  for( int i=0; i<numEigenVectors; i++ )
  {
     u.setName(sPrintF("v%d",i),i);
  }
  Index I1,I2,I3; 
  getIndex(mg.dimension(),I1,I2,I3);                        // assign I1,I2,I3 from dimension

  u=0.;
  // u(I1,I2,I3,0)=sin(Pi*mg.vertex()(I1,I2,I3,axis1))         // component 0 : sin(pi*x)*cos(pi*y)
  //              *cos(Pi*mg.vertex()(I1,I2,I3,axis2));        
  // u(I1,I2,I3,1)=cos(Pi*mg.vertex()(I1,I2,I3,axis1))         // component 1 : cos(pi*x)*sin(pi*y)
  //              *sin(Pi*mg.vertex()(I1,I2,I3,axis2));       


  // // Create the object that knows how to evaluate the boundary of the eye-lid
  // EyeCurves eyeCurves;
  
  real time=0.; // plot curve at this time
  
  // ========== create the GUI and dialog ================
  GUIState dialog;
  dialog.setWindowTitle("Eigenvalues Code");
  dialog.setExitCommand("exit", "exit");

  aString cmds[] = {"compute",
                    "contour",
                    "movie",
                    "erase",
                    "save file",
                    "" };
  int numberOfPushButtons=0;  // number of entries in cmds
  while( cmds[numberOfPushButtons]!="" ){numberOfPushButtons++;}; // 
  int numRows=(numberOfPushButtons+1)/2;
  dialog.setPushButtons( cmds, cmds, numRows ); 

  const int numberOfTextStrings=15;  // max number allowed
  aString textLabels[numberOfTextStrings];
  aString textStrings[numberOfTextStrings];

  int nt=0;
  textLabels[nt] = "time:";  sPrintF(textStrings[nt],"%g",time);  nt++; 
  textLabels[nt] = "numPoints:";  sPrintF(textStrings[nt],"%i",numPoints);  nt++; 
  // null strings terminal list
  textLabels[nt]="";   textStrings[nt]="";  assert( nt<numberOfTextStrings );
  dialog.setTextBoxes(textLabels, textLabels, textStrings);

  gi.pushGUI(dialog);
  gi.appendToTheDefaultPrompt("genEigs>");
  psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,true);
 
  aString answer,buff;  
  for( ;; )
  {
    gi.getAnswer(answer,"");  
 
    if( answer=="continue" )
    {
      break;
    }
    else if( answer=="exit" || answer=="done" )
    {
      break;
    }
    else if( answer=="compute" )
    {
      computeEigenvalues( numEigenValues,numEigenVectors, u );
    }    
    else if( answer=="contour" )
    {
      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,false);      
      psp.set(GI_TOP_LABEL,sPrintF("Eigenvector"));  // set title
      PlotIt::contour(gi, u,psp );
      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,true);      
    }    
    else if( dialog.getTextValue(answer,"time:","%g",time) ){}// 
    else if( dialog.getTextValue(answer,"numPoints:","%i",numPoints) ){}// 
    else if( answer=="erase" )
    {
      gi.erase();
    }
    // else if( answer=="movie" )
    // {
    //   // --- plot a movie of the eye motion ---

    //   // fix the plot bounds as the eye moves 
    //   RealArray xBound(2,3);
    //   xBound(0,0)=-1.2; xBound(1,0)= 1.2;
    //   xBound(0,1)=-1.2; xBound(1,1)= 1.2;
    //   xBound(0,2)=-1.;  xBound(1,2)= 1.;

    //   real dt=.005*Pi, tFinal=10*Pi;
    //   int nStep=int( tFinal/dt + .5 );
    //   dt = tFinal/(nStep);

    //   real yMax=-1.e10; // keep track of the largest y value of the eye-lid 

    //   RealArray x;
    //   for( int step=0; step<nStep; step++ )
    //   {
    //     real t=step*dt;
        
    //     eyeCurves.getEyeCurve( x,t,numPoints );

    //     Range R = x.dimension(0);
    //     real yTop = max(x(R,1));
    //     if( yTop>yMax )
    //     {
    //       yMax=yTop;
    //     }
    //     else if( yTop>yMax*(.99999) )
    //     {
    //       printF("Eye reaches yMax=%9.3e at t=%9.3e t/(2*pi)=%9.3e\n",yMax,t,t/twoPi);
    //     }
        
    //     gi.erase();
    //     psp.set(GI_TOP_LABEL,sPrintF(buff,"genEigs: t=%9.2e, yMax=%8.2e",t,yMax));
    //     plotCurve( x, gi,psp );
    //     gi.setGlobalBound(xBound); // set plot bounds         

    //     gi.redraw(true);
    //   }

    // }

    // else if( answer=="save file" )
    // {
    //   aString fileName = "eyeCurveDataPoints.dat";
    //   eyeCurves.saveEyeCurve( time, numPoints, fileName );
    //   printF("Eye coordinates written to file=[%s]\n",(const char*)fileName);
    // }
    
    else
    {
      printF("Unknown response=[%s]\n",(const char*)answer);
    }
  }
  

  gi.unAppendTheDefaultPrompt();
  gi.popGUI(); // restore the previous GUI


  int ierr = SlepcFinalize();

  Overture::finish();  

  return 0;
}

